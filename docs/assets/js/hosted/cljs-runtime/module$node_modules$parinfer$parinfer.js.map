{
"version":3,
"file":"module$node_modules$parinfer$parinfer.js",
"lineCount":26,
"mappings":"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",
"sources":["node_modules/parinfer/parinfer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$parinfer$parinfer\"] = function(global,process,require,module,exports) {\n//\n// Parinfer 3.12.0\n//\n// Copyright 2015-2017 \u00a9 Shaun Lebron\n// MIT License\n//\n// Home Page: http://shaunlebron.github.io/parinfer/\n// GitHub: https://github.com/shaunlebron/parinfer\n//\n// For DOCUMENTATION on this file, please see `doc/code.md`.\n// Use `sync.sh` to keep the function/var links in `doc/code.md` accurate.\n//\n\n//------------------------------------------------------------------------------\n// JS Module Boilerplate\n//------------------------------------------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  }\n  else {\n    root.parinfer = factory();\n  }\n}(this, function() { // start module anonymous scope\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants / Predicates\n//------------------------------------------------------------------------------\n\n// NOTE: this is a performance hack\n// The main result object uses a lot of \"unsigned integer or null\" values.\n// Using a negative integer is faster than actual null because it cuts down on\n// type coercion overhead.\nvar UINT_NULL = -999;\n\nvar INDENT_MODE = \"INDENT_MODE\",\n    PAREN_MODE = \"PAREN_MODE\";\n\nvar BACKSLASH = '\\\\',\n    BLANK_SPACE = ' ',\n    DOUBLE_SPACE = '  ',\n    DOUBLE_QUOTE = '\"',\n    NEWLINE = '\\n',\n    SEMICOLON = ';',\n    TAB = '\\t';\n\nvar LINE_ENDING_REGEX = /\\r?\\n/;\n\nvar MATCH_PAREN = {\n  \"{\": \"}\",\n  \"}\": \"{\",\n  \"[\": \"]\",\n  \"]\": \"[\",\n  \"(\": \")\",\n  \")\": \"(\"\n};\n\n// toggle this to check the asserts during development\nvar RUN_ASSERTS = false;\n\nfunction isBoolean(x) {\n  return typeof x === 'boolean';\n}\n\nfunction isArray(x) {\n  return Array.isArray(x);\n}\n\nfunction isInteger(x) {\n  return typeof x === 'number' &&\n         isFinite(x) &&\n         Math.floor(x) === x;\n}\n\n//------------------------------------------------------------------------------\n// Options Structure\n//------------------------------------------------------------------------------\n\nfunction transformChange(change) {\n  if (!change) {\n    return undefined;\n  }\n\n  var newLines = change.newText.split(LINE_ENDING_REGEX);\n  var oldLines = change.oldText.split(LINE_ENDING_REGEX);\n\n  // single line case:\n  //     (defn foo| [])\n  //              ^ newEndX, newEndLineNo\n  //           +++\n\n  // multi line case:\n  //     (defn foo\n  //           ++++\n  //        \"docstring.\"\n  //     ++++++++++++++++\n  //       |[])\n  //     ++^ newEndX, newEndLineNo\n\n  var lastOldLineLen = oldLines[oldLines.length-1].length;\n  var lastNewLineLen = newLines[newLines.length-1].length;\n\n  var oldEndX = (oldLines.length === 1 ? change.x : 0) + lastOldLineLen;\n  var newEndX = (newLines.length === 1 ? change.x : 0) + lastNewLineLen;\n  var newEndLineNo = change.lineNo + (newLines.length-1);\n\n  return {\n    x: change.x,\n    lineNo: change.lineNo,\n    oldText: change.oldText,\n    newText: change.newText,\n\n    oldEndX: oldEndX,\n    newEndX: newEndX,\n    newEndLineNo: newEndLineNo,\n\n    lookupLineNo: newEndLineNo,\n    lookupX: newEndX\n  };\n}\n\nfunction transformChanges(changes) {\n  if (changes.length === 0) {\n    return null;\n  }\n  var lines = {};\n  var line, i, change;\n  for (i=0; i<changes.length; i++) {\n    change = transformChange(changes[i]);\n    line = lines[change.lookupLineNo];\n    if (!line) {\n      line = lines[change.lookupLineNo] = {};\n    }\n    line[change.lookupX] = change;\n  }\n  return lines;\n}\n\nfunction parseOptions(options) {\n  options = options || {};\n  return {\n    cursorX: options.cursorX,\n    cursorLine: options.cursorLine,\n    prevCursorX: options.prevCursorX,\n    prevCursorLine: options.prevCursorLine,\n    selectionStartLine: options.selectionStartLine,\n    changes: options.changes,\n    partialResult: options.partialResult,\n    forceBalance: options.forceBalance,\n    returnParens: options.returnParens\n  };\n}\n\n//------------------------------------------------------------------------------\n// Result Structure\n//------------------------------------------------------------------------------\n\n// This represents the running result. As we scan through each character\n// of a given text, we mutate this structure to update the state of our\n// system.\n\nfunction initialParenTrail() {\n  return {\n    lineNo: UINT_NULL,       // [integer] - line number of the last parsed paren trail\n    startX: UINT_NULL,       // [integer] - x position of first paren in this range\n    endX: UINT_NULL,         // [integer] - x position after the last paren in this range\n    openers: [],             // [array of stack elements] - corresponding open-paren for each close-paren in this range\n    clamped: {\n      startX: UINT_NULL,     // startX before paren trail was clamped\n      endX: UINT_NULL,       // endX before paren trail was clamped\n      openers: []            // openers that were cut out after paren trail was clamped\n    }\n  };\n}\n\nfunction getInitialResult(text, options, mode, smart) {\n\n  var result = {\n\n    mode: mode,                // [enum] - current processing mode (INDENT_MODE or PAREN_MODE)\n    smart: smart,              // [boolean] - smart mode attempts special user-friendly behavior\n\n    origText: text,            // [string] - original text\n    origCursorX: UINT_NULL,    // [integer] - original cursorX option\n    origCursorLine: UINT_NULL, // [integer] - original cursorLine option\n\n    inputLines:                // [string array] - input lines that we process line-by-line, char-by-char\n      text.split(LINE_ENDING_REGEX),\n    inputLineNo: -1,           // [integer] - the current input line number\n    inputX: -1,                // [integer] - the current input x position of the current character (ch)\n\n    lines: [],                 // [string array] - output lines (with corrected parens or indentation)\n    lineNo: -1,                // [integer] - output line number we are on\n    ch: \"\",                    // [string] - character we are processing (can be changed to indicate a replacement)\n    x: 0,                      // [integer] - output x position of the current character (ch)\n    indentX: UINT_NULL,        // [integer] - x position of the indentation point if present\n\n    parenStack: [],            // We track where we are in the Lisp tree by keeping a stack (array) of open-parens.\n                               // Stack elements are objects containing keys {ch, x, lineNo, indentDelta}\n                               // whose values are the same as those described here in this result structure.\n\n    tabStops: [],              // In Indent Mode, it is useful for editors to snap a line's indentation\n                               // to certain critical points.  Thus, we have a `tabStops` array of objects containing\n                               // keys {ch, x, lineNo, argX}, which is just the state of the `parenStack` at the cursor line.\n\n    parenTrail: initialParenTrail(), // the range of parens at the end of a line\n\n    parenTrails: [],           // [array of {lineNo, startX, endX}] - all non-empty parenTrails to be returned\n\n    returnParens: false,       // [boolean] - determines if we return `parens` described below\n    parens: [],                // [array of {lineNo, x, closer, children}] - paren tree if `returnParens` is true\n\n    cursorX: UINT_NULL,        // [integer] - x position of the cursor\n    cursorLine: UINT_NULL,     // [integer] - line number of the cursor\n    prevCursorX: UINT_NULL,    // [integer] - x position of the previous cursor\n    prevCursorLine: UINT_NULL, // [integer] - line number of the previous cursor\n\n    selectionStartLine: UINT_NULL, // [integer] - line number of the current selection starting point\n\n    changes: null,             // [object] - mapping change.key to a change object (please see `transformChange` for object structure)\n\n    isInCode: true,            // [boolean] - indicates if we are currently in \"code space\" (not string or comment)\n    isEscaping: false,         // [boolean] - indicates if the next character will be escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isEscaped: false,          // [boolean] - indicates if the current character is escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isInStr: false,            // [boolean] - indicates if we are currently inside a string\n    isInComment: false,        // [boolean] - indicates if we are currently inside a comment\n    commentX: UINT_NULL,       // [integer] - x position of the start of comment on current line (if any)\n\n    quoteDanger: false,        // [boolean] - indicates if quotes are imbalanced inside of a comment (dangerous)\n    trackingIndent: false,     // [boolean] - are we looking for the indentation point of the current line?\n    skipChar: false,           // [boolean] - should we skip the processing of the current character?\n    success: false,            // [boolean] - was the input properly formatted enough to create a valid result?\n    partialResult: false,      // [boolean] - should we return a partial result when an error occurs?\n    forceBalance: false,       // [boolean] - should indent mode aggressively enforce paren balance?\n\n    maxIndent: UINT_NULL,      // [integer] - maximum allowed indentation of subsequent lines in Paren Mode\n    indentDelta: 0,            // [integer] - how far indentation was shifted by Paren Mode\n                               //  (preserves relative indentation of nested expressions)\n\n    trackingArgTabStop: null,  // [string] - enum to track how close we are to the first-arg tabStop in a list\n                               //  For example a tabStop occurs at `bar` below:\n                               //\n                               //         `   (foo    bar`\n                               //          00011112222000  <-- state after processing char (enums below)\n                               //\n                               //         0   null    => not searching\n                               //         1   'space' => searching for next space\n                               //         2   'arg'   => searching for arg\n                               //\n                               //    (We create the tabStop when the change from 2->0 happens.)\n                               //\n\n    error: {                   // if 'success' is false, return this error to the user\n      name: null,              // [string] - Parinfer's unique name for this error\n      message: null,           // [string] - error message to display\n      lineNo: null,            // [integer] - line number of error\n      x: null,                 // [integer] - start x position of error\n      extra: {\n        name: null,\n        lineNo: null,\n        x: null\n      }\n    },\n    errorPosCache: {}          // [object] - maps error name to a potential error position\n  };\n\n  // Make sure no new properties are added to the result, for type safety.\n  // (uncomment only when debugging, since it incurs a perf penalty)\n  // Object.preventExtensions(result);\n  // Object.preventExtensions(result.parenTrail);\n\n  // merge options if they are valid\n  if (options) {\n    if (isInteger(options.cursorX))            { result.cursorX            = options.cursorX;\n                                                 result.origCursorX        = options.cursorX; }\n    if (isInteger(options.cursorLine))         { result.cursorLine         = options.cursorLine;\n                                                 result.origCursorLine     = options.cursorLine; }\n    if (isInteger(options.prevCursorX))        { result.prevCursorX        = options.prevCursorX; }\n    if (isInteger(options.prevCursorLine))     { result.prevCursorLine     = options.prevCursorLine; }\n    if (isInteger(options.selectionStartLine)) { result.selectionStartLine = options.selectionStartLine; }\n    if (isArray(options.changes))              { result.changes            = transformChanges(options.changes); }\n    if (isBoolean(options.partialResult))      { result.partialResult      = options.partialResult; }\n    if (isBoolean(options.forceBalance))       { result.forceBalance       = options.forceBalance; }\n    if (isBoolean(options.returnParens))       { result.returnParens       = options.returnParens; }\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Possible Errors\n//------------------------------------------------------------------------------\n\n// `result.error.name` is set to any of these\nvar ERROR_QUOTE_DANGER = \"quote-danger\";\nvar ERROR_EOL_BACKSLASH = \"eol-backslash\";\nvar ERROR_UNCLOSED_QUOTE = \"unclosed-quote\";\nvar ERROR_UNCLOSED_PAREN = \"unclosed-paren\";\nvar ERROR_UNMATCHED_CLOSE_PAREN = \"unmatched-close-paren\";\nvar ERROR_UNMATCHED_OPEN_PAREN = \"unmatched-open-paren\";\nvar ERROR_LEADING_CLOSE_PAREN = \"leading-close-paren\";\nvar ERROR_UNHANDLED = \"unhandled\";\n\nvar errorMessages = {};\nerrorMessages[ERROR_QUOTE_DANGER] = \"Quotes must balanced inside comment blocks.\";\nerrorMessages[ERROR_EOL_BACKSLASH] = \"Line cannot end in a hanging backslash.\";\nerrorMessages[ERROR_UNCLOSED_QUOTE] = \"String is missing a closing quote.\";\nerrorMessages[ERROR_UNCLOSED_PAREN] = \"Unclosed open-paren.\";\nerrorMessages[ERROR_UNMATCHED_CLOSE_PAREN] = \"Unmatched close-paren.\";\nerrorMessages[ERROR_UNMATCHED_OPEN_PAREN] = \"Unmatched open-paren.\";\nerrorMessages[ERROR_LEADING_CLOSE_PAREN] = \"Line cannot lead with a close-paren.\";\nerrorMessages[ERROR_UNHANDLED] = \"Unhandled error.\";\n\nfunction cacheErrorPos(result, errorName) {\n  var e = {\n    lineNo: result.lineNo,\n    x: result.x,\n    inputLineNo: result.inputLineNo,\n    inputX: result.inputX\n  };\n  result.errorPosCache[errorName] = e;\n  return e;\n}\n\nfunction error(result, name) {\n  var cache = result.errorPosCache[name];\n\n  var keyLineNo = result.partialResult ? 'lineNo' : 'inputLineNo';\n  var keyX = result.partialResult ? 'x' : 'inputX';\n\n  var e = {\n    parinferError: true,\n    name: name,\n    message: errorMessages[name],\n    lineNo: cache ? cache[keyLineNo] : result[keyLineNo],\n    x: cache ? cache[keyX] : result[keyX]\n  };\n  var opener = peek(result.parenStack, 0);\n\n  if (name === ERROR_UNMATCHED_CLOSE_PAREN) {\n    // extra error info for locating the open-paren that it should've matched\n    cache = result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n    if (cache || opener) {\n      e.extra = {\n        name: ERROR_UNMATCHED_OPEN_PAREN,\n        lineNo: cache ? cache[keyLineNo] : opener[keyLineNo],\n        x: cache ? cache[keyX] : opener[keyX]\n      };\n    }\n  }\n  else if (name === ERROR_UNCLOSED_PAREN) {\n    e.lineNo = opener[keyLineNo];\n    e.x = opener[keyX];\n  }\n  return e;\n}\n\n//------------------------------------------------------------------------------\n// String Operations\n//------------------------------------------------------------------------------\n\nfunction replaceWithinString(orig, start, end, replace) {\n  return (\n    orig.substring(0, start) +\n    replace +\n    orig.substring(end)\n  );\n}\n\nif (RUN_ASSERTS) {\n  console.assert(replaceWithinString('aaa', 0, 2, '') === 'a');\n  console.assert(replaceWithinString('aaa', 0, 1, 'b') === 'baa');\n  console.assert(replaceWithinString('aaa', 0, 2, 'b') === 'ba');\n}\n\nfunction repeatString(text, n) {\n  var i;\n  var result = \"\";\n  for (i = 0; i < n; i++) {\n    result += text;\n  }\n  return result;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(repeatString('a', 2) === 'aa');\n  console.assert(repeatString('aa', 3) === 'aaaaaa');\n  console.assert(repeatString('aa', 0) === '');\n  console.assert(repeatString('', 0) === '');\n  console.assert(repeatString('', 5) === '');\n}\n\nfunction getLineEnding(text) {\n  // NOTE: We assume that if the CR char \"\\r\" is used anywhere,\n  //       then we should use CRLF line-endings after every line.\n  var i = text.search(\"\\r\");\n  if (i !== -1) {\n    return \"\\r\\n\";\n  }\n  return \"\\n\";\n}\n\n//------------------------------------------------------------------------------\n// Line operations\n//------------------------------------------------------------------------------\n\nfunction isCursorAffected(result, start, end) {\n  if (result.cursorX === start &&\n      result.cursorX === end) {\n    return result.cursorX === 0;\n  }\n  return result.cursorX >= end;\n}\n\nfunction shiftCursorOnEdit(result, lineNo, start, end, replace) {\n  var oldLength = end - start;\n  var newLength = replace.length;\n  var dx = newLength - oldLength;\n\n  if (dx !== 0 &&\n      result.cursorLine === lineNo &&\n      result.cursorX !== UINT_NULL &&\n      isCursorAffected(result, start, end)) {\n    result.cursorX += dx;\n  }\n}\n\nfunction replaceWithinLine(result, lineNo, start, end, replace) {\n  var line = result.lines[lineNo];\n  var newLine = replaceWithinString(line, start, end, replace);\n  result.lines[lineNo] = newLine;\n\n  shiftCursorOnEdit(result, lineNo, start, end, replace);\n}\n\nfunction insertWithinLine(result, lineNo, idx, insert) {\n  replaceWithinLine(result, lineNo, idx, idx, insert);\n}\n\nfunction initLine(result) {\n  result.x = 0;\n  result.lineNo++;\n\n  // reset line-specific state\n  result.indentX = UINT_NULL;\n  result.commentX = UINT_NULL;\n  result.indentDelta = 0;\n  delete result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  delete result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n  delete result.errorPosCache[ERROR_LEADING_CLOSE_PAREN];\n\n  result.trackingArgTabStop = null;\n  result.trackingIndent = !result.isInStr;\n}\n\n// if the current character has changed, commit its change to the current line.\nfunction commitChar(result, origCh) {\n  var ch = result.ch;\n  if (origCh !== ch) {\n    replaceWithinLine(result, result.lineNo, result.x, result.x + origCh.length, ch);\n    result.indentDelta -= (origCh.length - ch.length);\n  }\n  result.x += ch.length;\n}\n\n//------------------------------------------------------------------------------\n// Misc Utils\n//------------------------------------------------------------------------------\n\nfunction clamp(val, minN, maxN) {\n  if (minN !== UINT_NULL) {\n    val = Math.max(minN, val);\n  }\n  if (maxN !== UINT_NULL) {\n    val = Math.min(maxN, val);\n  }\n  return val;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(clamp(1, 3, 5) === 3);\n  console.assert(clamp(9, 3, 5) === 5);\n  console.assert(clamp(1, 3, UINT_NULL) === 3);\n  console.assert(clamp(5, 3, UINT_NULL) === 5);\n  console.assert(clamp(1, UINT_NULL, 5) === 1);\n  console.assert(clamp(9, UINT_NULL, 5) === 5);\n  console.assert(clamp(1, UINT_NULL, UINT_NULL) === 1);\n}\n\nfunction peek(arr, idxFromBack) {\n  var maxIdx = arr.length - 1;\n  if (idxFromBack > maxIdx) {\n    return null;\n  }\n  return arr[maxIdx - idxFromBack];\n}\n\nif (RUN_ASSERTS) {\n  console.assert(peek(['a'], 0) === 'a');\n  console.assert(peek(['a'], 1) === null);\n  console.assert(peek(['a', 'b', 'c'], 0) === 'c');\n  console.assert(peek(['a', 'b', 'c'], 1) === 'b');\n  console.assert(peek(['a', 'b', 'c'], 5) === null);\n  console.assert(peek([], 0) === null);\n  console.assert(peek([], 1) === null);\n}\n\n//------------------------------------------------------------------------------\n// Questions about characters\n//------------------------------------------------------------------------------\n\nfunction isOpenParen(ch) {\n  return ch === \"{\" || ch === \"(\" || ch === \"[\";\n}\n\nfunction isCloseParen(ch) {\n  return ch === \"}\" || ch === \")\" || ch === \"]\";\n}\n\nfunction isValidCloseParen(parenStack, ch) {\n  if (parenStack.length === 0) {\n    return false;\n  }\n  return peek(parenStack, 0).ch === MATCH_PAREN[ch];\n}\n\nfunction isWhitespace(result) {\n  var ch = result.ch;\n  return !result.isEscaped && (ch === BLANK_SPACE || ch === DOUBLE_SPACE);\n}\n\n// can this be the last code character of a list?\nfunction isClosable(result) {\n  var ch = result.ch;\n  var closer = (isCloseParen(ch) && !result.isEscaped);\n  return result.isInCode && !isWhitespace(result) && ch !== \"\" && !closer;\n}\n\n//------------------------------------------------------------------------------\n// Advanced operations on characters\n//------------------------------------------------------------------------------\n\nfunction checkCursorHolding(result) {\n  var opener = peek(result.parenStack, 0);\n  var parent = peek(result.parenStack, 1);\n  var holdMinX = parent ? parent.x+1 : 0;\n  var holdMaxX = opener.x;\n\n  var holding = (\n    result.cursorLine === opener.lineNo &&\n    holdMinX <= result.cursorX && result.cursorX <= holdMaxX\n  );\n  var shouldCheckPrev = !result.changes && result.prevCursorLine !== UINT_NULL;\n  if (shouldCheckPrev) {\n    var prevHolding = (\n      result.prevCursorLine === opener.lineNo &&\n      holdMinX <= result.prevCursorX && result.prevCursorX <= holdMaxX\n    );\n    if (prevHolding && !holding) {\n      throw {releaseCursorHold: true};\n    }\n  }\n  return holding;\n}\n\nfunction trackArgTabStop(result, state) {\n  if (state === 'space') {\n    if (result.isInCode && isWhitespace(result)) {\n      result.trackingArgTabStop = 'arg';\n    }\n  }\n  else if (state === 'arg') {\n    if (!isWhitespace(result)) {\n        var opener = peek(result.parenStack, 0);\n        opener.argX = result.x;\n        result.trackingArgTabStop = null;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Literal character events\n//------------------------------------------------------------------------------\n\nfunction onOpenParen(result) {\n  if (result.isInCode) {\n    var opener = {\n      inputLineNo: result.inputLineNo,\n      inputX: result.inputX,\n\n      lineNo: result.lineNo,\n      x: result.x,\n      ch: result.ch,\n      indentDelta: result.indentDelta,\n      maxChildIndent: UINT_NULL\n    };\n\n    if (result.returnParens) {\n      opener.children = [];\n      opener.closer = {\n        lineNo: UINT_NULL,\n        x: UINT_NULL,\n        ch: ''\n      };\n      var parent = peek(result.parenStack, 0);\n      parent = parent ? parent.children : result.parens;\n      parent.push(opener);\n    }\n\n    result.parenStack.push(opener);\n    result.trackingArgTabStop = 'space';\n  }\n}\n\nfunction setCloser(opener, lineNo, x, ch) {\n  opener.closer.lineNo = lineNo;\n  opener.closer.x = x;\n  opener.closer.ch = ch;\n}\n\nfunction onMatchedCloseParen(result) {\n  var opener = peek(result.parenStack, 0);\n  if (result.returnParens) {\n    setCloser(opener, result.lineNo, result.x, result.ch);\n  }\n\n  result.parenTrail.endX = result.x + 1;\n  result.parenTrail.openers.push(opener);\n\n  if (result.mode === INDENT_MODE && result.smart && checkCursorHolding(result)) {\n    var origStartX = result.parenTrail.startX;\n    var origEndX = result.parenTrail.endX;\n    var origOpeners = result.parenTrail.openers;\n    resetParenTrail(result, result.lineNo, result.x+1);\n    result.parenTrail.clamped.startX = origStartX;\n    result.parenTrail.clamped.endX = origEndX;\n    result.parenTrail.clamped.openers = origOpeners;\n  }\n  result.parenStack.pop();\n  result.trackingArgTabStop = null;\n}\n\nfunction onUnmatchedCloseParen(result) {\n  if (result.mode === PAREN_MODE) {\n    var trail = result.parenTrail;\n    var inLeadingParenTrail = trail.lineNo === result.lineNo && trail.startX === result.indentX;\n    var canRemove = result.smart && inLeadingParenTrail;\n    if (!canRemove) {\n      throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    }\n  }\n  else if (result.mode === INDENT_MODE && !result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN]) {\n    cacheErrorPos(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    var opener = peek(result.parenStack, 0);\n    if (opener) {\n      var e = cacheErrorPos(result, ERROR_UNMATCHED_OPEN_PAREN);\n      e.inputLineNo = opener.inputLineNo;\n      e.inputX = opener.inputX;\n    }\n  }\n  result.ch = \"\";\n}\n\nfunction onCloseParen(result) {\n  if (result.isInCode) {\n    if (isValidCloseParen(result.parenStack, result.ch)) {\n      onMatchedCloseParen(result);\n    }\n    else {\n      onUnmatchedCloseParen(result);\n    }\n  }\n}\n\nfunction onTab(result) {\n  if (result.isInCode) {\n    result.ch = DOUBLE_SPACE;\n  }\n}\n\nfunction onSemicolon(result) {\n  if (result.isInCode) {\n    result.isInComment = true;\n    result.commentX = result.x;\n    result.trackingArgTabStop = null;\n  }\n}\n\nfunction onNewline(result) {\n  result.isInComment = false;\n  result.ch = \"\";\n}\n\nfunction onQuote(result) {\n  if (result.isInStr) {\n    result.isInStr = false;\n  }\n  else if (result.isInComment) {\n    result.quoteDanger = !result.quoteDanger;\n    if (result.quoteDanger) {\n      cacheErrorPos(result, ERROR_QUOTE_DANGER);\n    }\n  }\n  else {\n    result.isInStr = true;\n    cacheErrorPos(result, ERROR_UNCLOSED_QUOTE);\n  }\n}\n\nfunction onBackslash(result) {\n  result.isEscaping = true;\n}\n\nfunction afterBackslash(result) {\n  result.isEscaping = false;\n  result.isEscaped = true;\n\n  if (result.ch === NEWLINE) {\n    if (result.isInCode) {\n      throw error(result, ERROR_EOL_BACKSLASH);\n    }\n    onNewline(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Character dispatch\n//------------------------------------------------------------------------------\n\nfunction onChar(result) {\n  var ch = result.ch;\n  result.isEscaped = false;\n\n  if (result.isEscaping)        { afterBackslash(result); }\n  else if (isOpenParen(ch))     { onOpenParen(result); }\n  else if (isCloseParen(ch))    { onCloseParen(result); }\n  else if (ch === DOUBLE_QUOTE) { onQuote(result); }\n  else if (ch === SEMICOLON)    { onSemicolon(result); }\n  else if (ch === BACKSLASH)    { onBackslash(result); }\n  else if (ch === TAB)          { onTab(result); }\n  else if (ch === NEWLINE)      { onNewline(result); }\n\n  ch = result.ch;\n\n  result.isInCode = !result.isInComment && !result.isInStr;\n\n  if (isClosable(result)) {\n    resetParenTrail(result, result.lineNo, result.x+ch.length);\n  }\n\n  var state = result.trackingArgTabStop;\n  if (state) {\n     trackArgTabStop(result, state);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Cursor functions\n//------------------------------------------------------------------------------\n\nfunction isCursorLeftOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX <= x // inclusive since (cursorX = x) implies (x-1 < cursor < x)\n  );\n}\n\nfunction isCursorRightOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX > x\n  );\n}\n\nfunction isCursorInComment(result, cursorX, cursorLine) {\n  return isCursorRightOf(cursorX, cursorLine, result.commentX, result.lineNo);\n}\n\nfunction handleChangeDelta(result) {\n  if (result.changes && (result.smart || result.mode === PAREN_MODE)) {\n    var line = result.changes[result.inputLineNo];\n    if (line) {\n      var change = line[result.inputX];\n      if (change) {\n        result.indentDelta += (change.newEndX - change.oldEndX);\n      }\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Paren Trail functions\n//------------------------------------------------------------------------------\n\nfunction resetParenTrail(result, lineNo, x) {\n  result.parenTrail.lineNo = lineNo;\n  result.parenTrail.startX = x;\n  result.parenTrail.endX = x;\n  result.parenTrail.openers = [];\n  result.parenTrail.clamped.startX = UINT_NULL;\n  result.parenTrail.clamped.endX = UINT_NULL;\n  result.parenTrail.clamped.openers = [];\n}\n\nfunction isCursorClampingParenTrail(result, cursorX, cursorLine) {\n  return (\n    isCursorRightOf(cursorX, cursorLine, result.parenTrail.startX, result.lineNo) &&\n    !isCursorInComment(result, cursorX, cursorLine)\n  );\n}\n\n// INDENT MODE: allow the cursor to clamp the paren trail\nfunction clampParenTrailToCursor(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  var clamping = isCursorClampingParenTrail(result, result.cursorX, result.cursorLine);\n\n  if (clamping) {\n    var newStartX = Math.max(startX, result.cursorX);\n    var newEndX = Math.max(endX, result.cursorX);\n\n    var line = result.lines[result.lineNo];\n    var removeCount = 0;\n    var i;\n    for (i = startX; i < newStartX; i++) {\n      if (isCloseParen(line[i])) {\n        removeCount++;\n      }\n    }\n\n    var openers = result.parenTrail.openers;\n\n    result.parenTrail.openers = openers.slice(removeCount);\n    result.parenTrail.startX = newStartX;\n    result.parenTrail.endX = newEndX;\n\n    result.parenTrail.clamped.openers = openers.slice(0, removeCount);\n    result.parenTrail.clamped.startX = startX;\n    result.parenTrail.clamped.endX = endX;\n  }\n}\n\n// INDENT MODE: pops the paren trail from the stack\nfunction popParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX) {\n    return;\n  }\n\n  var openers = result.parenTrail.openers;\n  while (openers.length !== 0) {\n    result.parenStack.push(openers.pop());\n  }\n}\n\n// Determine which open-paren (if any) on the parenStack should be considered\n// the direct parent of the current line (given its indentation point).\n// This allows Smart Mode to simulate Paren Mode's structure-preserving\n// behavior by adding its `opener.indentDelta` to the current line's indentation.\n// (care must be taken to prevent redundant indentation correction, detailed below)\nfunction getParentOpenerIndex(result, indentX) {\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    var opener = peek(result.parenStack, i);\n\n    var currOutside = (opener.x < indentX);\n\n    var prevIndentX = indentX - result.indentDelta;\n    var prevOutside = (opener.x - opener.indentDelta < prevIndentX);\n\n    var isParent = false;\n\n    if (prevOutside && currOutside) {\n      isParent = true;\n    }\n    else if (!prevOutside && !currOutside) {\n      isParent = false;\n    }\n    else if (prevOutside && !currOutside) {\n      // POSSIBLE FRAGMENTATION\n      // (foo    --\\\n      //            +--- FRAGMENT `(foo bar)` => `(foo) bar`\n      // bar)    --/\n\n      // 1. PREVENT FRAGMENTATION\n      // ```in\n      //   (foo\n      // ++\n      //   bar\n      // ```\n      // ```out\n      //   (foo\n      //     bar\n      // ```\n      if (result.indentDelta === 0) {\n        isParent = true;\n      }\n\n      // 2. ALLOW FRAGMENTATION\n      // ```in\n      // (foo\n      //   bar\n      // --\n      // ```\n      // ```out\n      // (foo)\n      // bar\n      // ```\n      else if (opener.indentDelta === 0) {\n        isParent = false;\n      }\n\n      else {\n        // TODO: identify legitimate cases where both are nonzero\n\n        // allow the fragmentation by default\n        isParent = false;\n\n        // TODO: should we throw to exit instead?  either of:\n        // 1. give up, just `throw error(...)`\n        // 2. fallback to paren mode to preserve structure\n      }\n    }\n    else if (!prevOutside && currOutside) {\n      // POSSIBLE ADOPTION\n      // (foo)   --\\\n      //            +--- ADOPT `(foo) bar` => `(foo bar)`\n      //   bar   --/\n\n      var nextOpener = peek(result.parenStack, i+1);\n\n      // 1. DISALLOW ADOPTION\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar)\n      //   baz)\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // -\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //  (bar)\n      //  baz)\n      // ```\n      if (nextOpener && nextOpener.indentDelta <= opener.indentDelta) {\n        // we can only disallow adoption if nextOpener.indentDelta will actually\n        // prevent the indentX from being in the opener's threshold.\n        if (indentX + nextOpener.indentDelta > opener.x) {\n          isParent = true;\n        }\n        else {\n          isParent = false;\n        }\n      }\n\n      // 2. ALLOW ADOPTION\n      // ```in\n      // (foo\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar\n      //     baz))\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // -\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      //  (foo\n      //   (bar)\n      //    baz)\n      // ```\n      else if (nextOpener && nextOpener.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      // 3. ALLOW ADOPTION\n      // ```in\n      //   (foo)\n      // --\n      //   bar\n      // ```\n      // ```out\n      // (foo\n      //   bar)\n      // ```\n      // OR\n      // ```in\n      // (foo)\n      //   bar\n      // ++\n      // ```\n      // ```out\n      // (foo\n      //   bar\n      // ```\n      // OR\n      // ```in\n      //  (foo)\n      // +\n      //   bar\n      // ++\n      // ```\n      // ```out\n      //  (foo\n      //   bar)\n      // ```\n      else if (result.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      if (isParent) { // if new parent\n        // Clear `indentDelta` since it is reserved for previous child lines only.\n        opener.indentDelta = 0;\n      }\n    }\n\n    if (isParent) {\n      break;\n    }\n  }\n  return i;\n}\n\n// INDENT MODE: correct paren trail from indentation\nfunction correctParenTrail(result, indentX) {\n  var parens = \"\";\n\n  var index = getParentOpenerIndex(result, indentX);\n  var i;\n  for (i=0; i<index; i++) {\n    var opener = result.parenStack.pop();\n    result.parenTrail.openers.push(opener);\n    var closeCh = MATCH_PAREN[opener.ch];\n    parens += closeCh;\n\n    if (result.returnParens) {\n      setCloser(opener, result.parenTrail.lineNo, result.parenTrail.startX+i, closeCh);\n    }\n  }\n\n  if (result.parenTrail.lineNo !== UINT_NULL) {\n    replaceWithinLine(result, result.parenTrail.lineNo, result.parenTrail.startX, result.parenTrail.endX, parens);\n    result.parenTrail.endX = result.parenTrail.startX + parens.length;\n    rememberParenTrail(result);\n  }\n}\n\n// PAREN MODE: remove spaces from the paren trail\nfunction cleanParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX ||\n      result.lineNo !== result.parenTrail.lineNo) {\n    return;\n  }\n\n  var line = result.lines[result.lineNo];\n  var newTrail = \"\";\n  var spaceCount = 0;\n  var i;\n  for (i = startX; i < endX; i++) {\n    if (isCloseParen(line[i])) {\n      newTrail += line[i];\n    }\n    else {\n      spaceCount++;\n    }\n  }\n\n  if (spaceCount > 0) {\n    replaceWithinLine(result, result.lineNo, startX, endX, newTrail);\n    result.parenTrail.endX -= spaceCount;\n  }\n}\n\n// PAREN MODE: append a valid close-paren to the end of the paren trail\nfunction appendParenTrail(result) {\n  var opener = result.parenStack.pop();\n  var closeCh = MATCH_PAREN[opener.ch];\n  if (result.returnParens) {\n    setCloser(opener, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n  }\n\n  setMaxIndent(result, opener);\n  insertWithinLine(result, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n\n  result.parenTrail.endX++;\n  result.parenTrail.openers.push(opener);\n  updateRememberedParenTrail(result);\n}\n\nfunction invalidateParenTrail(result) {\n  result.parenTrail = initialParenTrail();\n}\n\nfunction checkUnmatchedOutsideParenTrail(result) {\n  var cache = result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  if (cache && cache.x < result.parenTrail.startX) {\n    throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n  }\n}\n\nfunction setMaxIndent(result, opener) {\n  if (opener) {\n    var parent = peek(result.parenStack, 0);\n    if (parent) {\n      parent.maxChildIndent = opener.x;\n    }\n    else {\n      result.maxIndent = opener.x;\n    }\n  }\n}\n\nfunction rememberParenTrail(result) {\n  var trail = result.parenTrail;\n  var openers = trail.clamped.openers.concat(trail.openers);\n  if (openers.length > 0) {\n    var isClamped = trail.clamped.startX !== UINT_NULL;\n    var allClamped = trail.openers.length === 0;\n    var shortTrail = {\n      lineNo: trail.lineNo,\n      startX: isClamped ? trail.clamped.startX : trail.startX,\n      endX: allClamped ? trail.clamped.endX : trail.endX\n    };\n    result.parenTrails.push(shortTrail);\n\n    if (result.returnParens) {\n      var i;\n      for (i=0; i<openers.length; i++) {\n        openers[i].closer.trail = shortTrail;\n      }\n    }\n  }\n}\n\nfunction updateRememberedParenTrail(result) {\n  var trail = result.parenTrails[result.parenTrails.length-1];\n  if (!trail || trail.lineNo !== result.parenTrail.lineNo) {\n    rememberParenTrail(result);\n  }\n  else {\n    trail.endX = result.parenTrail.endX;\n    if (result.returnParens) {\n      var opener = result.parenTrail.openers[result.parenTrail.openers.length-1];\n      opener.closer.trail = trail;\n    }\n  }\n}\n\nfunction finishNewParenTrail(result) {\n  if (result.isInStr) {\n    invalidateParenTrail(result);\n  }\n  else if (result.mode === INDENT_MODE) {\n    clampParenTrailToCursor(result);\n    popParenTrail(result);\n  }\n  else if (result.mode === PAREN_MODE) {\n    setMaxIndent(result, peek(result.parenTrail.openers, 0));\n    if (result.lineNo !== result.cursorLine) {\n      cleanParenTrail(result);\n    }\n    rememberParenTrail(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Indentation functions\n//------------------------------------------------------------------------------\n\nfunction addIndent(result, delta) {\n  var origIndent = result.x;\n  var newIndent = origIndent + delta;\n  var indentStr = repeatString(BLANK_SPACE, newIndent);\n  replaceWithinLine(result, result.lineNo, 0, origIndent, indentStr);\n  result.x = newIndent;\n  result.indentX = newIndent;\n  result.indentDelta += delta;\n}\n\nfunction shouldAddOpenerIndent(result, opener) {\n  // Don't add opener.indentDelta if the user already added it.\n  // (happens when multiple lines are indented together)\n  return (opener.indentDelta !== result.indentDelta);\n}\n\nfunction correctIndent(result) {\n  var origIndent = result.x;\n  var newIndent = origIndent;\n  var minIndent = 0;\n  var maxIndent = result.maxIndent;\n\n  var opener = peek(result.parenStack, 0);\n  if (opener) {\n    minIndent = opener.x + 1;\n    maxIndent = opener.maxChildIndent;\n    if (shouldAddOpenerIndent(result, opener)) {\n      newIndent += opener.indentDelta;\n    }\n  }\n\n  newIndent = clamp(newIndent, minIndent, maxIndent);\n\n  if (newIndent !== origIndent) {\n    addIndent(result, newIndent - origIndent);\n  }\n}\n\nfunction onIndent(result) {\n  result.indentX = result.x;\n  result.trackingIndent = false;\n\n  if (result.quoteDanger) {\n    throw error(result, ERROR_QUOTE_DANGER);\n  }\n\n  if (result.mode === INDENT_MODE) {\n\n    correctParenTrail(result, result.x);\n\n    var opener = peek(result.parenStack, 0);\n    if (opener && shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n  }\n  else if (result.mode === PAREN_MODE) {\n    correctIndent(result);\n  }\n}\n\nfunction checkLeadingCloseParen(result) {\n  if (result.errorPosCache[ERROR_LEADING_CLOSE_PAREN] &&\n      result.parenTrail.lineNo === result.lineNo) {\n    throw error(result, ERROR_LEADING_CLOSE_PAREN);\n  }\n}\n\nfunction onLeadingCloseParen(result) {\n  if (result.mode === INDENT_MODE) {\n    if (!result.forceBalance) {\n      if (result.smart) {\n        throw {leadingCloseParen: true};\n      }\n      if (!result.errorPosCache[ERROR_LEADING_CLOSE_PAREN]) {\n        cacheErrorPos(result, ERROR_LEADING_CLOSE_PAREN);\n      }\n    }\n    result.skipChar = true;\n  }\n  if (result.mode === PAREN_MODE) {\n    if (!isValidCloseParen(result.parenStack, result.ch)) {\n      if (result.smart) {\n        result.skipChar = true;\n      }\n      else {\n        throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n      }\n    }\n    else if (isCursorLeftOf(result.cursorX, result.cursorLine, result.x, result.lineNo)) {\n      resetParenTrail(result, result.lineNo, result.x);\n      onIndent(result);\n    }\n    else {\n      appendParenTrail(result);\n      result.skipChar = true;\n    }\n  }\n}\n\nfunction onCommentLine(result) {\n  var parenTrailLength = result.parenTrail.openers.length;\n\n  // restore the openers matching the previous paren trail\n  var j;\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.push(peek(result.parenTrail.openers, j));\n    }\n  }\n\n  var i = getParentOpenerIndex(result, result.x);\n  var opener = peek(result.parenStack, i);\n  if (opener) {\n    // shift the comment line based on the parent open paren\n    if (shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n    // TODO: store some information here if we need to place close-parens after comment lines\n  }\n\n  // repop the openers matching the previous paren trail\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.pop();\n    }\n  }\n}\n\nfunction checkIndent(result) {\n  if (isCloseParen(result.ch)) {\n    onLeadingCloseParen(result);\n  }\n  else if (result.ch === SEMICOLON) {\n    // comments don't count as indentation points\n    onCommentLine(result);\n    result.trackingIndent = false;\n  }\n  else if (result.ch !== NEWLINE &&\n           result.ch !== BLANK_SPACE &&\n           result.ch !== TAB) {\n    onIndent(result);\n  }\n}\n\nfunction makeTabStop(result, opener) {\n  var tabStop = {\n    ch: opener.ch,\n    x: opener.x,\n    lineNo: opener.lineNo\n  };\n  if (opener.argX != null) {\n    tabStop.argX = opener.argX;\n  }\n  return tabStop;\n}\n\nfunction getTabStopLine(result) {\n  return result.selectionStartLine !== UINT_NULL ? result.selectionStartLine : result.cursorLine;\n}\n\nfunction setTabStops(result) {\n  if (getTabStopLine(result) !== result.lineNo) {\n    return;\n  }\n\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    result.tabStops.push(makeTabStop(result, result.parenStack[i]));\n  }\n\n  if (result.mode === PAREN_MODE) {\n    for (i=result.parenTrail.openers.length-1; i>=0; i--) {\n      result.tabStops.push(makeTabStop(result, result.parenTrail.openers[i]));\n    }\n  }\n\n  // remove argX if it falls to the right of the next stop\n  for (i=1; i<result.tabStops.length; i++) {\n    var x = result.tabStops[i].x;\n    var prevArgX = result.tabStops[i-1].argX;\n    if (prevArgX != null && prevArgX >= x) {\n      delete result.tabStops[i-1].argX;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// High-level processing functions\n//------------------------------------------------------------------------------\n\nfunction processChar(result, ch) {\n  var origCh = ch;\n\n  result.ch = ch;\n  result.skipChar = false;\n\n  handleChangeDelta(result);\n\n  if (result.trackingIndent) {\n    checkIndent(result);\n  }\n\n  if (result.skipChar) {\n    result.ch = \"\";\n  }\n  else {\n    onChar(result);\n  }\n\n  commitChar(result, origCh);\n}\n\nfunction processLine(result, lineNo) {\n  initLine(result);\n  result.lines.push(result.inputLines[lineNo]);\n\n  setTabStops(result);\n\n  var x;\n  for (x = 0; x < result.inputLines[lineNo].length; x++) {\n    result.inputX = x;\n    processChar(result, result.inputLines[lineNo][x]);\n  }\n  processChar(result, NEWLINE);\n\n  if (!result.forceBalance) {\n    checkUnmatchedOutsideParenTrail(result);\n    checkLeadingCloseParen(result);\n  }\n\n  if (result.lineNo === result.parenTrail.lineNo) {\n    finishNewParenTrail(result);\n  }\n}\n\nfunction finalizeResult(result) {\n  if (result.quoteDanger) { throw error(result, ERROR_QUOTE_DANGER); }\n  if (result.isInStr)     { throw error(result, ERROR_UNCLOSED_QUOTE); }\n\n  if (result.parenStack.length !== 0) {\n    if (result.mode === PAREN_MODE) {\n      throw error(result, ERROR_UNCLOSED_PAREN);\n    }\n  }\n  if (result.mode === INDENT_MODE) {\n    initLine(result);\n    onIndent(result);\n  }\n  result.success = true;\n}\n\nfunction processError(result, e) {\n  result.success = false;\n  if (e.parinferError) {\n    delete e.parinferError;\n    result.error = e;\n  }\n  else {\n    result.error.name = ERROR_UNHANDLED;\n    result.error.message = e.stack;\n    throw e;\n  }\n}\n\nfunction processText(text, options, mode, smart) {\n  var result = getInitialResult(text, options, mode, smart);\n\n  try {\n    var i;\n    for (i = 0; i < result.inputLines.length; i++) {\n      result.inputLineNo = i;\n      processLine(result, i);\n    }\n    finalizeResult(result);\n  }\n  catch (e) {\n    if (e.leadingCloseParen || e.releaseCursorHold) {\n      return processText(text, options, PAREN_MODE, smart);\n    }\n    processError(result, e);\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nfunction publicResult(result) {\n  var lineEnding = getLineEnding(result.origText);\n  var final;\n  if (result.success) {\n    final = {\n      text: result.lines.join(lineEnding),\n      cursorX: result.cursorX,\n      cursorLine: result.cursorLine,\n      success: true,\n      tabStops: result.tabStops,\n      parenTrails: result.parenTrails\n    };\n    if (result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  else {\n    final = {\n      text: result.partialResult ? result.lines.join(lineEnding) : result.origText,\n      cursorX: result.partialResult ? result.cursorX : result.origCursorX,\n      cursorLine: result.partialResult ? result.cursorLine : result.origCursorLine,\n      parenTrails: result.partialResult ? result.parenTrails : null,\n      success: false,\n      error: result.error\n    };\n    if (result.partialResult && result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  if (final.cursorX === UINT_NULL) { delete final.cursorX; }\n  if (final.cursorLine === UINT_NULL) { delete final.cursorLine; }\n  if (final.tabStops && final.tabStops.length === 0) { delete final.tabStops; }\n  return final;\n}\n\nfunction indentMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, INDENT_MODE));\n}\n\nfunction parenMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, PAREN_MODE));\n}\n\nfunction smartMode(text, options) {\n  options = parseOptions(options);\n  var smart = options.selectionStartLine == null;\n  return publicResult(processText(text, options, INDENT_MODE, smart));\n}\n\nvar API = {\n  version: \"3.12.0\",\n  indentMode: indentMode,\n  parenMode: parenMode,\n  smartMode: smartMode\n};\n\nreturn API;\n\n})); // end module anonymous scope\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","root","factory","define","amd","parinfer","isInteger","x","isFinite","Math","floor","parseOptions","options","cursorX","cursorLine","prevCursorX","prevCursorLine","selectionStartLine","changes","partialResult","forceBalance","returnParens","initialParenTrail","lineNo","UINT_NULL","startX","endX","openers","clamped","cacheErrorPos","result","errorName","e","inputLineNo","inputX","errorPosCache","error","name","cache","keyLineNo","keyX","parinferError","message","errorMessages","opener","peek","parenStack","ERROR_UNMATCHED_CLOSE_PAREN","ERROR_UNMATCHED_OPEN_PAREN","extra","ERROR_UNCLOSED_PAREN","replaceWithinLine","start","end","replace","line","lines","orig","substring","newLine","dx","length","initLine","indentX","commentX","indentDelta","ERROR_LEADING_CLOSE_PAREN","trackingArgTabStop","trackingIndent","isInStr","arr","idxFromBack","maxIdx","isCloseParen","ch","isValidCloseParen","MATCH_PAREN","isWhitespace","isEscaped","BLANK_SPACE","DOUBLE_SPACE","isCursorRightOf","resetParenTrail","parenTrail","getParentOpenerIndex","i","currOutside","prevOutside","isParent","nextOpener","setMaxIndent","parent","maxChildIndent","maxIndent","rememberParenTrail","trail","concat","shortTrail","parenTrails","push","closer","addIndent","delta","origIndent","newIndent","onIndent","quoteDanger","ERROR_QUOTE_DANGER","INDENT_MODE","mode","parens","index","pop","closeCh","PAREN_MODE","minIndent","val","max","min","makeTabStop","tabStop","argX","processChar","skipChar","smart","change","newEndX","oldEndX","leadingCloseParen","idx","SEMICOLON","parenTrailLength","j","NEWLINE","TAB","isEscaping","isInCode","ERROR_EOL_BACKSLASH","isInComment","children","holdMinX","holdMaxX","holding","releaseCursorHold","origStartX","origEndX","origOpeners","canRemove","inLeadingParenTrail","DOUBLE_QUOTE","ERROR_UNCLOSED_QUOTE","BACKSLASH","state","processText","text","origText","origCursorX","origCursorLine","inputLines","split","LINE_ENDING_REGEX","tabStops","success","Array","isArray","newLines","newText","oldLines","oldText","newEndLineNo","lookupLineNo","lookupX","prevArgX","newStartX","removeCount","slice","newTrail","spaceCount","ERROR_UNHANDLED","stack","publicResult","search","final","join","lineEnding","API","version","indentMode","parenMode","smartMode"]
}
