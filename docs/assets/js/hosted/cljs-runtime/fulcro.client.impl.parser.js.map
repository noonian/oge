{"version":3,"file":"fulcro.client.impl.parser.js","sources":["fulcro/client/impl/parser.cljc"],"mappings":"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","names":["fulcro.client.impl.parser/mark-meta","source","target","G__36742","cljs.core/meta","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","fulcro.client.impl.parser/symbol->ast","k","fulcro.client.impl.parser/keyword->ast","p__36746","vec__36747","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","fulcro.client.impl.parser/union-entry->ast","v","component","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","cljs.core.into.cljs$core$IFn$_invoke$arity$3","cljs.core.map.cljs$core$IFn$_invoke$arity$1","fulcro.client.impl.parser/expr->ast","fulcro.client.impl.parser/union->ast","m","p__36751","vec__36752","fulcro.client.impl.parser/call->ast","f","args","call","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","or__3922__auto__","ast","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core/merge","G__36756","cljs.core/Symbol","fulcro.client.impl.parser/query->ast","query","fulcro.client.impl.parser/join->ast","join","vec__36767","query-root?","cljs.core/first","type","cljs.core/vector?","cljs.core/map?","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","p__36784","vec__36785","fulcro.client.impl.parser/ident->ast","id","ref","x","cljs.core/Keyword","cljs.core/seq?","fulcro.client.impl.parser/wrap-expr","root?","expr","cljs.core/with-meta","G__36792","cljs.core/List","fulcro.client.impl.parser/parameterize","params","cljs.core/empty?","var_args","G__36803","fulcro.client.impl.parser/ast->expr","js/Error","p__36805","map__36806","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","fulcro.client.impl.parser.ast__GT_expr.cljs$core$IFn$_invoke$arity$2","ast-meta","unparse?","G__36811","p1__36799#","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","map__36812","key","query-root","and__3911__auto__","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","map__36814","children","query-meta","cljs.core/count","G__36816","p__36817","map__36818","union-key","G__36820","p1__36800#","G__36821","p1__36801#","G__36844","fulcro.client.impl.parser/path-meta","data","path","fulcro.client.impl.parser.path_meta.cljs$core$IFn$_invoke$arity$4","union-expr","G__36846","cljs.core/native-satisfies?","cljs.core/IWithMeta","cljs.core/sequential?","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$1","idx","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","joins","cljs.core/seq","ret","cljs.core/not","fulcro.util/join?","fulcro.util/ident?","cljs.core/next","vec__36849","G__36852","G__36853","cljs.core/PersistentHashMap","sel","fulcro.util/join-entry","union-entry","fulcro.util/union?","fulcro.util/recursion?","G__36854","fulcro.util/unique-ident?","G__36855","cljs.core/contains?","G__36856","dispatch-key","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","branches","cljs.core/vals","props","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","q","query-props","cljs.core/set","cljs.core/reduced","clojure.set/subset?","fulcro.client.impl.parser/rethrow?","cljs.core/ExceptionInfo","cljs.core/ex-data","p__36875","map__36876","fulcro.client.impl.parser/parser","read","mutate","config","env","fulcro$client$impl$parser$parser_$_self.cljs$core$IFn$_invoke$arity$3","map__36878","G__36879","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","self","map__36893","query'","G__36895","call?","res","G__36896","ast'","G__36897","fulcro.client.impl.parser.ast__GT_expr.cljs$core$IFn$_invoke$arity$1","p1__36871#","p2__36872#","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$5","cljs.core/update","cljs.core.into.cljs$core$IFn$_invoke$arity$2","error","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","mut-ret","e36898","cljs.core/reset!","fexpr__36899","e","value","G__36900","cljs.core/deref","G__36901","cljs.core/assoc-in","p1__36873#","p2__36874#","step","fulcro.client.impl.parser/dispatch","_"],"sourcesContent":["(ns\n  ^{:doc \"\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot      := EdnVector(QueryExpr*)\n   PlainQueryExpr := (EdnKeyword | IdentExpr | JoinExpr)\n   QueryExpr      := (PlainQueryExpr | ParamExpr)\n   IdentExpr      := EdnVector2(Keyword, EdnValue)\n   ParamExpr      := EdnList2(PlainQueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr   := EdnMap(Keyword, EdnValue)\n   JoinExpr       := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr      := EdnMap(Keyword, QueryRoot)\n   RecurExpr      := ('... | Integer)\n\n   Note most of the api expects a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object\n    :target       EdnKeyword}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations.\"}\n  fulcro.client.impl.parser\n  (:require [clojure.set :as set]\n            [fulcro.util :as util]))\n\n(declare expr->ast)\n\n(defn- mark-meta [source target]\n  (cond-> target\n    (meta source) (assoc :meta (meta source))))\n\n(defn symbol->ast [k]\n  {:dispatch-key k\n   :key          k})\n\n(defn keyword->ast [k]\n  {:type         :prop\n   :dispatch-key k\n   :key          k})\n\n(defn union-entry->ast [[k v]]\n  (let [component (-> v meta :component)]\n    (merge\n      {:type      :union-entry\n       :union-key k\n       :query     v\n       :children  (into [] (map expr->ast) v)}\n      (when-not (nil? component)\n        {:component component}))))\n\n(defn union->ast [m]\n  {:type     :union\n   :query    m\n   :children (into [] (map union-entry->ast) m)})\n\n(defn call->ast [[f args :as call]]\n  (if (= 'quote f)\n    (assoc (expr->ast args) :target (or (-> call meta :target) :remote))\n    (let [ast (update-in (expr->ast f) [:params] merge (or args {}))]\n      (cond-> (mark-meta call ast)\n        (symbol? (:dispatch-key ast)) (assoc :type :call)))))\n\n(defn query->ast\n  \"Convert a query to its AST representation.\"\n  [query]\n  (let [component (-> query meta :component)]\n    (merge\n      (mark-meta query\n        {:type     :root\n         :children (into [] (map expr->ast) query)})\n      (when-not (nil? component)\n        {:component component}))))\n\n(defn join->ast [join]\n  (let [query-root? (-> join meta :query-root)\n        [k v] (first join)\n        ast         (expr->ast k)\n        type        (if (= :call (:type ast)) :call :join)\n        component   (-> v meta :component)]\n    (merge ast\n      (mark-meta join {:type type :query v})\n      (when-not (nil? component)\n        {:component component})\n      (when query-root?\n        {:query-root true})\n      (when-not (or (number? v) (= '... v))\n        (cond\n          (vector? v) {:children (into [] (map expr->ast) v)}\n          (map? v) {:children [(union->ast v)]}\n          :else (throw\n                  (ex-info (str \"Invalid join, \" join)\n                    {:type :error/invalid-join})))))))\n\n(defn ident->ast [[k id :as ref]]\n  {:type         :prop\n   :dispatch-key k\n   :key          ref})\n\n(defn expr->ast\n  \"Given a query expression convert it into an AST.\"\n  [x]\n  (cond\n    (symbol? x) (symbol->ast x)\n    (keyword? x) (keyword->ast x)\n    (map? x) (join->ast x)\n    (vector? x) (ident->ast x)\n    (seq? x) (call->ast x)\n    :else (throw\n            (ex-info (str \"Invalid expression \" x)\n              {:type :error/invalid-expression}))))\n\n(defn wrap-expr [root? expr]\n  (if root?\n    (with-meta\n      (cond-> expr (keyword? expr) list)\n      {:query-root true})\n    expr))\n\n(defn parameterize [expr params]\n  (if-not (empty? params)\n    (list expr params)\n    (list expr)))\n\n(defn ast->expr\n  \"Given a query expression AST convert it back into a query expression.\"\n  ([ast]\n   (ast->expr ast false))\n  ([{:keys [type component] ast-meta :meta :as ast} unparse?]\n   (if (= :root type)\n     (cond-> (into (with-meta [] ast-meta) (map #(ast->expr % unparse?)) (:children ast))\n       (not (nil? component)) (vary-meta assoc :component component))\n     (let [{:keys [key query query-root params]} ast]\n       (wrap-expr query-root\n         (if (and params (not= :call type))\n           (let [expr (ast->expr (dissoc ast :params) unparse?)]\n             (parameterize expr params))\n           (let [key (if (= :call type) (parameterize key params) key)]\n             (if (or (= :join type)\n                     (and (= :call type) (:children ast)))\n               (if (and (not= '... query) (not (number? query))\n                        (or (true? unparse?)\n                            (= :call type)))\n                 (let [{:keys [children]} ast\n                       query-meta (meta query)]\n                   (if (and (== 1 (count children))\n                            (= :union (:type (first children)))) ;; UNION\n                     (with-meta\n                       {key (into (cond-> (with-meta {} ast-meta)\n                                    component (vary-meta assoc :component component))\n                                  (map (fn [{:keys [union-key children component]}]\n                                         [union-key\n                                          (cond-> (into [] (map #(ast->expr % unparse?)) children)\n                                            (not (nil? component)) (vary-meta assoc :component component))]))\n                                  (:children (first children)))}\n                       ast-meta)\n                     (with-meta\n                       {key (cond-> (into (with-meta [] query-meta) (map #(ast->expr % unparse?)) children)\n                              (not (nil? component)) (vary-meta assoc :component component))}\n                       ast-meta)))\n                 (with-meta {key query} ast-meta))\n               key))))))))\n\n(defn path-meta\n  \"Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.\"\n  ([data path query]\n   (path-meta data path query nil))\n  ([data path query union-expr]\n   (cond\n     (nil? query)\n     (cond-> data\n       #?(:clj  (instance? clojure.lang.IObj data)\n          :cljs (satisfies? IWithMeta data))\n       (vary-meta assoc :om-path path))\n\n     (sequential? data)\n     (-> (into []\n           (map-indexed\n             (fn [idx v]\n               (path-meta v (conj path idx) query union-expr))) data)\n       (vary-meta assoc :om-path path))\n\n     (vector? query)\n     (loop [joins (seq query) ret data]\n       (if-not (nil? joins)\n         (let [join (first joins)]\n           (if-not (or (util/join? join)\n                     (util/ident? join)\n                     (and (seq? join)\n                       (util/ident? (first join))))\n             (recur (next joins) ret)\n             (let [join        (cond-> join (seq? join) first)\n                   join        (cond-> join (util/ident? join) (hash-map '[*]))\n                   [key sel] (util/join-entry join)\n                   union-entry (if (util/union? join) sel union-expr)\n                   sel         (if (util/recursion? sel)\n                                 (if-not (nil? union-expr)\n                                   union-entry\n                                   query)\n                                 sel)\n                   key         (cond-> key (util/unique-ident? key) first)\n                   v           (get ret key)]\n               (recur (next joins)\n                 (cond-> ret\n                   (and (map? ret) (contains? ret key))\n                   (assoc key\n                          (path-meta v (conj path key) sel union-entry)))))))\n         (cond-> ret\n           #?(:clj  (instance? clojure.lang.IObj ret)\n              :cljs (satisfies? IWithMeta ret))\n           (vary-meta assoc :om-path path))))\n\n     :else\n     ;; UNION\n     (if (map? data)\n       (let [dispatch-key (comp :dispatch-key expr->ast)\n             branches     (vals query)\n             props        (map dispatch-key (keys data))\n             query        (reduce (fn [ret q]\n                                    (let [query-props (into #{} (map dispatch-key) q)\n                                          props       (set props)]\n                                      (cond\n                                        (= (set props)\n                                          (set query-props)) (reduced q)\n                                        (set/subset? props query-props) q\n                                        :else ret)))\n                            nil branches)]\n         (path-meta data path query union-expr))\n       data))))\n\n(defn rethrow? [x]\n  (and (instance? #?(:clj clojure.lang.ExceptionInfo :cljs ExceptionInfo) x)\n    (= :fulcro.client.primitives/abort (-> x ex-data :type))))\n\n(defn parser\n  \"Given a :read and/or :mutate function return a parser. Refer to fulcro.client.primitives/parser\n   for top level documentation.\"\n  [{:keys [read mutate] :as config}]\n  (fn self\n    ([env query] (self env query nil))\n    ([env query target]\n     (let [target (or target (:target env))\n           {:keys [path] :as env}\n           (cond-> (assoc env :parser self :target target :query-root :fulcro.client.primitives/root)\n             (not (contains? env :path)) (assoc :path []))]\n       (letfn [(step [ret expr]\n                 (let [{query' :query :keys [key dispatch-key params] :as ast} (expr->ast expr)\n                       env   (cond-> (merge env {:ast ast :query query'})\n                               (nil? query') (dissoc :query)\n                               (= '... query') (assoc :query query)\n                               (vector? key) (assoc :query-root key))\n                       type  (:type ast)\n                       call? (= :call type)\n                       res   (case type\n                               :call\n                               (do\n                                 (assert mutate \"Parse mutation attempted but no :mutate function supplied\")\n                                 (mutate env dispatch-key params))\n                               (:prop :join :union)\n                               (do\n                                 (assert read \"Parse read attempted but no :read function supplied\")\n                                 (read env dispatch-key params)))]\n                   (if-not (nil? target)\n                     (let [ast' (get res target)]\n                       (cond-> ret\n                         (true? ast') (conj expr)\n                         (map? ast') (conj (ast->expr ast'))\n                         (seq (:refresh res)) (vary-meta update :fulcro.client.primitives/refresh #(into (or %1 #{}) %2) (:refresh res))))\n                     (if-not (or call? (nil? (:target ast)) (contains? res :value))\n                       ret\n                       (let [error   (atom nil)\n                             mut-ret (atom nil)]\n                         (when (and call? (not (nil? (:action res))))\n                           (try\n                             (reset! mut-ret ((:action res)))\n                             (catch #?(:clj Throwable :cljs :default) e\n                               (if (rethrow? e)\n                                 (throw e)\n                                 (reset! error e)))))\n                         (let [value (:value res)]\n                           (when call?\n                             (assert (or (nil? value) (map? value))\n                               ; FIXME: This no longer applies, but should be editing in a testing context.\n                               (str dispatch-key \" mutation :value must be nil or a map with structure {:refresh [...]}\")))\n                           (cond-> ret\n                             (not (nil? value)) (assoc (cond-> key\n                                                         (util/unique-ident? key)\n                                                         first)\n                                                       value)\n                             @mut-ret (assoc-in [key :result] @mut-ret)\n                             (seq (:refresh res)) (vary-meta update :fulcro.client.primitives/refresh #(into (or %1 #{}) %2) (:refresh res))\n                             @error (assoc key {:fulcro.client.primitives/error @error}))))))))]\n         (reduce step (if (nil? target) {} []) query))))))\n\n(defn dispatch [_ k _] k)\n"]}