{
"version":3,
"file":"module$com$wsscode$oge$vendor$parinfer.js",
"lineCount":25,
"mappings":"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",
"sources":["com/wsscode/oge/vendor/parinfer.js"],
"sourcesContent":["shadow$provide[\"module$com$wsscode$oge$vendor$parinfer\"] = function(global,process,require,module,exports) {\n//\n// Parinfer 3.10.0\n//\n// Copyright 2015-2017 \u00a9 Shaun Lebron\n// MIT License\n//\n// Home Page: http://shaunlebron.github.io/parinfer/\n// GitHub: https://github.com/shaunlebron/parinfer\n//\n// For DOCUMENTATION on this file, please see `doc/code.md`.\n// Use `sync.sh` to keep the function/var links in `doc/code.md` accurate.\n//\n\n//------------------------------------------------------------------------------\n// JS Module Boilerplate\n//------------------------------------------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  }\n  else {\n    root.parinfer = factory();\n  }\n}(this, function() { // start module anonymous scope\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants / Predicates\n//------------------------------------------------------------------------------\n\n// NOTE: this is a performance hack\n// The main result object uses a lot of \"unsigned integer or null\" values.\n// Using a negative integer is faster than actual null because it cuts down on\n// type coercion overhead.\nvar UINT_NULL = -999;\n\nvar INDENT_MODE = \"INDENT_MODE\",\n    PAREN_MODE = \"PAREN_MODE\";\n\nvar BACKSLASH = '\\\\',\n    BLANK_SPACE = ' ',\n    DOUBLE_SPACE = '  ',\n    DOUBLE_QUOTE = '\"',\n    NEWLINE = '\\n',\n    SEMICOLON = ';',\n    TAB = '\\t';\n\nvar LINE_ENDING_REGEX = /\\r?\\n/;\n\nvar MATCH_PAREN = {\n  \"{\": \"}\",\n  \"}\": \"{\",\n  \"[\": \"]\",\n  \"]\": \"[\",\n  \"(\": \")\",\n  \")\": \"(\"\n};\n\n// toggle this to check the asserts during development\nvar RUN_ASSERTS = false;\n\nfunction isBoolean(x) {\n  return typeof x === 'boolean';\n}\n\nfunction isArray(x) {\n  return Array.isArray(x);\n}\n\nfunction isInteger(x) {\n  return typeof x === 'number' &&\n         isFinite(x) &&\n         Math.floor(x) === x;\n}\n\n//------------------------------------------------------------------------------\n// Options Structure\n//------------------------------------------------------------------------------\n\nfunction transformChange(change) {\n  if (!change) {\n    return undefined;\n  }\n\n  var newLines = change.newText.split(LINE_ENDING_REGEX);\n  var oldLines = change.oldText.split(LINE_ENDING_REGEX);\n\n  // single line case:\n  //     (defn foo| [])\n  //              ^ newEndX, newEndLineNo\n  //           +++\n\n  // multi line case:\n  //     (defn foo\n  //           ++++\n  //        \"docstring.\"\n  //     ++++++++++++++++\n  //       |[])\n  //     ++^ newEndX, newEndLineNo\n\n  var lastOldLineLen = oldLines[oldLines.length-1].length;\n  var lastNewLineLen = newLines[newLines.length-1].length;\n\n  var oldEndX = (oldLines.length === 1 ? change.x : 0) + lastOldLineLen;\n  var newEndX = (newLines.length === 1 ? change.x : 0) + lastNewLineLen;\n  var newEndLineNo = change.lineNo + (newLines.length-1);\n\n  return {\n    x: change.x,\n    lineNo: change.lineNo,\n    oldText: change.oldText,\n    newText: change.newText,\n\n    oldEndX: oldEndX,\n    newEndX: newEndX,\n    newEndLineNo: newEndLineNo,\n\n    lookupLineNo: newEndLineNo,\n    lookupX: newEndX\n  };\n}\n\nfunction transformChanges(changes) {\n  if (changes.length === 0) {\n    return null;\n  }\n  var lines = {};\n  var line, i, change;\n  for (i=0; i<changes.length; i++) {\n    change = transformChange(changes[i]);\n    line = lines[change.lookupLineNo];\n    if (!line) {\n      line = lines[change.lookupLineNo] = {};\n    }\n    line[change.lookupX] = change;\n  }\n  return lines;\n}\n\nfunction parseOptions(options) {\n  options = options || {};\n  return {\n    cursorX: options.cursorX,\n    cursorLine: options.cursorLine,\n    prevCursorX: options.prevCursorX,\n    prevCursorLine: options.prevCursorLine,\n    selectionStartLine: options.selectionStartLine,\n    changes: options.changes,\n    partialResult: options.partialResult,\n    forceBalance: options.forceBalance,\n    returnParens: options.returnParens\n  };\n}\n\n//------------------------------------------------------------------------------\n// Result Structure\n//------------------------------------------------------------------------------\n\n// This represents the running result. As we scan through each character\n// of a given text, we mutate this structure to update the state of our\n// system.\n\nfunction initialParenTrail() {\n  return {\n    lineNo: UINT_NULL,       // [integer] - line number of the last parsed paren trail\n    startX: UINT_NULL,       // [integer] - x position of first paren in this range\n    endX: UINT_NULL,         // [integer] - x position after the last paren in this range\n    openers: [],             // [array of stack elements] - corresponding open-paren for each close-paren in this range\n    clamped: {\n      startX: UINT_NULL,     // startX before paren trail was clamped\n      endX: UINT_NULL,       // endX before paren trail was clamped\n      openers: []            // openers that were cut out after paren trail was clamped\n    }\n  };\n}\n\nfunction getInitialResult(text, options, mode, smart) {\n\n  var result = {\n\n    mode: mode,                // [enum] - current processing mode (INDENT_MODE or PAREN_MODE)\n    smart: smart,              // [boolean] - smart mode attempts special user-friendly behavior\n\n    origText: text,            // [string] - original text\n    origCursorX: UINT_NULL,    // [integer] - original cursorX option\n    origCursorLine: UINT_NULL, // [integer] - original cursorLine option\n\n    inputLines:                // [string array] - input lines that we process line-by-line, char-by-char\n      text.split(LINE_ENDING_REGEX),\n    inputLineNo: -1,           // [integer] - the current input line number\n    inputX: -1,                // [integer] - the current input x position of the current character (ch)\n\n    lines: [],                 // [string array] - output lines (with corrected parens or indentation)\n    lineNo: -1,                // [integer] - output line number we are on\n    ch: \"\",                    // [string] - character we are processing (can be changed to indicate a replacement)\n    x: 0,                      // [integer] - output x position of the current character (ch)\n\n    parenStack: [],            // We track where we are in the Lisp tree by keeping a stack (array) of open-parens.\n                               // Stack elements are objects containing keys {ch, x, lineNo, indentDelta}\n                               // whose values are the same as those described here in this result structure.\n\n    tabStops: [],              // In Indent Mode, it is useful for editors to snap a line's indentation\n                               // to certain critical points.  Thus, we have a `tabStops` array of objects containing\n                               // keys {ch, x, lineNo, argX}, which is just the state of the `parenStack` at the cursor line.\n\n    parenTrail: initialParenTrail(), // the range of parens at the end of a line\n\n    parenTrails: [],           // [array of {lineNo, startX, endX}] - all non-empty parenTrails to be returned\n\n    returnParens: false,       // [boolean] - determines if we return `parens` described below\n    parens: [],                // [array of {lineNo, x, closer, children}] - paren tree if `returnParens` is true\n\n    cursorX: UINT_NULL,        // [integer] - x position of the cursor\n    cursorLine: UINT_NULL,     // [integer] - line number of the cursor\n    prevCursorX: UINT_NULL,    // [integer] - x position of the previous cursor\n    prevCursorLine: UINT_NULL, // [integer] - line number of the previous cursor\n\n    selectionStartLine: UINT_NULL, // [integer] - line number of the current selection starting point\n\n    changes: null,             // [object] - mapping change.key to a change object (please see `transformChange` for object structure)\n\n    isInCode: true,            // [boolean] - indicates if we are currently in \"code space\" (not string or comment)\n    isEscaping: false,         // [boolean] - indicates if the next character will be escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isEscaped: false,          // [boolean] - indicates if the current character is escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isInStr: false,            // [boolean] - indicates if we are currently inside a string\n    isInComment: false,        // [boolean] - indicates if we are currently inside a comment\n    commentX: UINT_NULL,       // [integer] - x position of the start of comment on current line (if any)\n\n    quoteDanger: false,        // [boolean] - indicates if quotes are imbalanced inside of a comment (dangerous)\n    trackingIndent: false,     // [boolean] - are we looking for the indentation point of the current line?\n    skipChar: false,           // [boolean] - should we skip the processing of the current character?\n    success: false,            // [boolean] - was the input properly formatted enough to create a valid result?\n    partialResult: false,      // [boolean] - should we return a partial result when an error occurs?\n    forceBalance: false,       // [boolean] - should indent mode aggressively enforce paren balance?\n\n    maxIndent: UINT_NULL,      // [integer] - maximum allowed indentation of subsequent lines in Paren Mode\n    indentDelta: 0,            // [integer] - how far indentation was shifted by Paren Mode\n                               //  (preserves relative indentation of nested expressions)\n\n    trackingArgTabStop: null,  // [string] - enum to track how close we are to the first-arg tabStop in a list\n                               //  For example a tabStop occurs at `bar` below:\n                               //\n                               //         `   (foo    bar`\n                               //          00011112222000  <-- state after processing char (enums below)\n                               //\n                               //         0   null    => not searching\n                               //         1   'space' => searching for next space\n                               //         2   'arg'   => searching for arg\n                               //\n                               //    (We create the tabStop when the change from 2->0 happens.)\n                               //\n\n    error: {                   // if 'success' is false, return this error to the user\n      name: null,              // [string] - Parinfer's unique name for this error\n      message: null,           // [string] - error message to display\n      lineNo: null,            // [integer] - line number of error\n      x: null,                 // [integer] - start x position of error\n      extra: {\n        name: null,\n        lineNo: null,\n        x: null\n      }\n    },\n    errorPosCache: {}          // [object] - maps error name to a potential error position\n  };\n\n  // Make sure no new properties are added to the result, for type safety.\n  // (uncomment only when debugging, since it incurs a perf penalty)\n  // Object.preventExtensions(result);\n  // Object.preventExtensions(result.parenTrail);\n\n  // merge options if they are valid\n  if (options) {\n    if (isInteger(options.cursorX))            { result.cursorX            = options.cursorX;\n                                                 result.origCursorX        = options.cursorX; }\n    if (isInteger(options.cursorLine))         { result.cursorLine         = options.cursorLine;\n                                                 result.origCursorLine     = options.cursorLine; }\n    if (isInteger(options.prevCursorX))        { result.prevCursorX        = options.prevCursorX; }\n    if (isInteger(options.prevCursorLine))     { result.prevCursorLine     = options.prevCursorLine; }\n    if (isInteger(options.selectionStartLine)) { result.selectionStartLine = options.selectionStartLine; }\n    if (isArray(options.changes))              { result.changes            = transformChanges(options.changes); }\n    if (isBoolean(options.partialResult))      { result.partialResult      = options.partialResult; }\n    if (isBoolean(options.forceBalance))       { result.forceBalance       = options.forceBalance; }\n    if (isBoolean(options.returnParens))       { result.returnParens       = options.returnParens; }\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Possible Errors\n//------------------------------------------------------------------------------\n\n// `result.error.name` is set to any of these\nvar ERROR_QUOTE_DANGER = \"quote-danger\";\nvar ERROR_EOL_BACKSLASH = \"eol-backslash\";\nvar ERROR_UNCLOSED_QUOTE = \"unclosed-quote\";\nvar ERROR_UNCLOSED_PAREN = \"unclosed-paren\";\nvar ERROR_UNMATCHED_CLOSE_PAREN = \"unmatched-close-paren\";\nvar ERROR_UNMATCHED_OPEN_PAREN = \"unmatched-open-paren\";\nvar ERROR_LEADING_CLOSE_PAREN = \"leading-close-paren\";\nvar ERROR_UNHANDLED = \"unhandled\";\n\nvar errorMessages = {};\nerrorMessages[ERROR_QUOTE_DANGER] = \"Quotes must balanced inside comment blocks.\";\nerrorMessages[ERROR_EOL_BACKSLASH] = \"Line cannot end in a hanging backslash.\";\nerrorMessages[ERROR_UNCLOSED_QUOTE] = \"String is missing a closing quote.\";\nerrorMessages[ERROR_UNCLOSED_PAREN] = \"Unclosed open-paren.\";\nerrorMessages[ERROR_UNMATCHED_CLOSE_PAREN] = \"Unmatched close-paren.\";\nerrorMessages[ERROR_UNMATCHED_OPEN_PAREN] = \"Unmatched open-paren.\";\nerrorMessages[ERROR_LEADING_CLOSE_PAREN] = \"Line cannot lead with a close-paren.\";\nerrorMessages[ERROR_UNHANDLED] = \"Unhandled error.\";\n\nfunction cacheErrorPos(result, errorName) {\n  var e = {\n    lineNo: result.lineNo,\n    x: result.x,\n    inputLineNo: result.inputLineNo,\n    inputX: result.inputX\n  };\n  result.errorPosCache[errorName] = e;\n  return e;\n}\n\nfunction error(result, name) {\n  var cache = result.errorPosCache[name];\n\n  var keyLineNo = result.partialResult ? 'lineNo' : 'inputLineNo';\n  var keyX = result.partialResult ? 'x' : 'inputX';\n\n  var e = {\n    parinferError: true,\n    name: name,\n    message: errorMessages[name],\n    lineNo: cache ? cache[keyLineNo] : result[keyLineNo],\n    x: cache ? cache[keyX] : result[keyX]\n  };\n  var opener = peek(result.parenStack, 0);\n\n  if (name === ERROR_UNMATCHED_CLOSE_PAREN) {\n    // extra error info for locating the open-paren that it should've matched\n    cache = result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n    if (cache || opener) {\n      e.extra = {\n        name: ERROR_UNMATCHED_OPEN_PAREN,\n        lineNo: cache ? cache[keyLineNo] : opener[keyLineNo],\n        x: cache ? cache[keyX] : opener[keyX]\n      };\n    }\n  }\n  else if (name === ERROR_UNCLOSED_PAREN) {\n    e.lineNo = opener[keyLineNo];\n    e.x = opener[keyX];\n  }\n  return e;\n}\n\n//------------------------------------------------------------------------------\n// String Operations\n//------------------------------------------------------------------------------\n\nfunction replaceWithinString(orig, start, end, replace) {\n  return (\n    orig.substring(0, start) +\n    replace +\n    orig.substring(end)\n  );\n}\n\nif (RUN_ASSERTS) {\n  console.assert(replaceWithinString('aaa', 0, 2, '') === 'a');\n  console.assert(replaceWithinString('aaa', 0, 1, 'b') === 'baa');\n  console.assert(replaceWithinString('aaa', 0, 2, 'b') === 'ba');\n}\n\nfunction repeatString(text, n) {\n  var i;\n  var result = \"\";\n  for (i = 0; i < n; i++) {\n    result += text;\n  }\n  return result;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(repeatString('a', 2) === 'aa');\n  console.assert(repeatString('aa', 3) === 'aaaaaa');\n  console.assert(repeatString('aa', 0) === '');\n  console.assert(repeatString('', 0) === '');\n  console.assert(repeatString('', 5) === '');\n}\n\nfunction getLineEnding(text) {\n  // NOTE: We assume that if the CR char \"\\r\" is used anywhere,\n  //       then we should use CRLF line-endings after every line.\n  var i = text.search(\"\\r\");\n  if (i !== -1) {\n    return \"\\r\\n\";\n  }\n  return \"\\n\";\n}\n\n//------------------------------------------------------------------------------\n// Line operations\n//------------------------------------------------------------------------------\n\nfunction isCursorAffected(result, start, end) {\n  if (result.cursorX === start &&\n      result.cursorX === end) {\n    return result.cursorX === 0;\n  }\n  return result.cursorX >= end;\n}\n\nfunction shiftCursorOnEdit(result, lineNo, start, end, replace) {\n  var oldLength = end - start;\n  var newLength = replace.length;\n  var dx = newLength - oldLength;\n\n  if (dx !== 0 &&\n      result.cursorLine === lineNo &&\n      result.cursorX !== UINT_NULL &&\n      isCursorAffected(result, start, end)) {\n    result.cursorX += dx;\n  }\n}\n\nfunction replaceWithinLine(result, lineNo, start, end, replace) {\n  var line = result.lines[lineNo];\n  var newLine = replaceWithinString(line, start, end, replace);\n  result.lines[lineNo] = newLine;\n\n  shiftCursorOnEdit(result, lineNo, start, end, replace);\n}\n\nfunction insertWithinLine(result, lineNo, idx, insert) {\n  replaceWithinLine(result, lineNo, idx, idx, insert);\n}\n\nfunction initLine(result, line) {\n  result.x = 0;\n  result.lineNo++;\n  result.lines.push(line);\n\n  // reset line-specific state\n  result.commentX = UINT_NULL;\n  result.indentDelta = 0;\n  delete result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  delete result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n  delete result.errorPosCache[ERROR_LEADING_CLOSE_PAREN];\n\n  result.trackingArgTabStop = null;\n  result.trackingIndent = !result.isInStr;\n}\n\n// if the current character has changed, commit its change to the current line.\nfunction commitChar(result, origCh) {\n  var ch = result.ch;\n  if (origCh !== ch) {\n    replaceWithinLine(result, result.lineNo, result.x, result.x + origCh.length, ch);\n    result.indentDelta -= (origCh.length - ch.length);\n  }\n  result.x += ch.length;\n}\n\n//------------------------------------------------------------------------------\n// Misc Utils\n//------------------------------------------------------------------------------\n\nfunction clamp(val, minN, maxN) {\n  if (minN !== UINT_NULL) {\n    val = Math.max(minN, val);\n  }\n  if (maxN !== UINT_NULL) {\n    val = Math.min(maxN, val);\n  }\n  return val;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(clamp(1, 3, 5) === 3);\n  console.assert(clamp(9, 3, 5) === 5);\n  console.assert(clamp(1, 3, UINT_NULL) === 3);\n  console.assert(clamp(5, 3, UINT_NULL) === 5);\n  console.assert(clamp(1, UINT_NULL, 5) === 1);\n  console.assert(clamp(9, UINT_NULL, 5) === 5);\n  console.assert(clamp(1, UINT_NULL, UINT_NULL) === 1);\n}\n\nfunction peek(arr, idxFromBack) {\n  var maxIdx = arr.length - 1;\n  if (idxFromBack > maxIdx) {\n    return null;\n  }\n  return arr[maxIdx - idxFromBack];\n}\n\nif (RUN_ASSERTS) {\n  console.assert(peek(['a'], 0) === 'a');\n  console.assert(peek(['a'], 1) === null);\n  console.assert(peek(['a', 'b', 'c'], 0) === 'c');\n  console.assert(peek(['a', 'b', 'c'], 1) === 'b');\n  console.assert(peek(['a', 'b', 'c'], 5) === null);\n  console.assert(peek([], 0) === null);\n  console.assert(peek([], 1) === null);\n}\n\n//------------------------------------------------------------------------------\n// Questions about characters\n//------------------------------------------------------------------------------\n\nfunction isOpenParen(ch) {\n  return ch === \"{\" || ch === \"(\" || ch === \"[\";\n}\n\nfunction isCloseParen(ch) {\n  return ch === \"}\" || ch === \")\" || ch === \"]\";\n}\n\nfunction isValidCloseParen(parenStack, ch) {\n  if (parenStack.length === 0) {\n    return false;\n  }\n  return peek(parenStack, 0).ch === MATCH_PAREN[ch];\n}\n\nfunction isWhitespace(result) {\n  var ch = result.ch;\n  return !result.isEscaped && (ch === BLANK_SPACE || ch === DOUBLE_SPACE);\n}\n\n// can this be the last code character of a list?\nfunction isClosable(result) {\n  var ch = result.ch;\n  var closer = (isCloseParen(ch) && !result.isEscaped);\n  return result.isInCode && !isWhitespace(result) && ch !== \"\" && !closer;\n}\n\n//------------------------------------------------------------------------------\n// Advanced operations on characters\n//------------------------------------------------------------------------------\n\nfunction checkCursorHolding(result) {\n  var opener = peek(result.parenStack, 0);\n  var parent = peek(result.parenStack, 1);\n  var holdMinX = parent ? parent.x+1 : 0;\n  var holdMaxX = opener.x;\n\n  var holding = (\n    result.cursorLine === opener.lineNo &&\n    holdMinX <= result.cursorX && result.cursorX <= holdMaxX\n  );\n  var shouldCheckPrev = !result.changes && result.prevCursorLine !== UINT_NULL;\n  if (shouldCheckPrev) {\n    var prevHolding = (\n      result.prevCursorLine === opener.lineNo &&\n      holdMinX <= result.prevCursorX && result.prevCursorX <= holdMaxX\n    );\n    if (prevHolding && !holding) {\n      throw {releaseCursorHold: true};\n    }\n  }\n  return holding;\n}\n\nfunction trackArgTabStop(result, state) {\n  if (state === 'space') {\n    if (result.isInCode && isWhitespace(result)) {\n      result.trackingArgTabStop = 'arg';\n    }\n  }\n  else if (state === 'arg') {\n    if (!isWhitespace(result)) {\n        var opener = peek(result.parenStack, 0);\n        opener.argX = result.x;\n        result.trackingArgTabStop = null;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Literal character events\n//------------------------------------------------------------------------------\n\nfunction onOpenParen(result) {\n  if (result.isInCode) {\n    var opener = {\n      inputLineNo: result.inputLineNo,\n      inputX: result.inputX,\n\n      lineNo: result.lineNo,\n      x: result.x,\n      ch: result.ch,\n      indentDelta: result.indentDelta,\n      maxChildIndent: UINT_NULL\n    };\n\n    if (result.returnParens) {\n      opener.children = [];\n      opener.closer = {\n        lineNo: UINT_NULL,\n        x: UINT_NULL,\n        ch: ''\n      };\n      var parent = peek(result.parenStack, 0);\n      parent = parent ? parent.children : result.parens;\n      parent.push(opener);\n    }\n\n    result.parenStack.push(opener);\n    result.trackingArgTabStop = 'space';\n  }\n}\n\nfunction setCloser(opener, lineNo, x, ch) {\n  opener.closer.lineNo = lineNo;\n  opener.closer.x = x;\n  opener.closer.ch = ch;\n}\n\nfunction onMatchedCloseParen(result) {\n  var opener = peek(result.parenStack, 0);\n  if (result.returnParens) {\n    setCloser(opener, result.lineNo, result.x, result.ch);\n  }\n\n  result.parenTrail.endX = result.x + 1;\n  result.parenTrail.openers.push(opener);\n\n  if (result.mode === INDENT_MODE && result.smart && checkCursorHolding(result)) {\n    var origStartX = result.parenTrail.startX;\n    var origEndX = result.parenTrail.endX;\n    var origOpeners = result.parenTrail.openers;\n    resetParenTrail(result, result.lineNo, result.x+1);\n    result.parenTrail.clamped.startX = origStartX;\n    result.parenTrail.clamped.endX = origEndX;\n    result.parenTrail.clamped.openers = origOpeners;\n  }\n  result.parenStack.pop();\n  result.trackingArgTabStop = null;\n}\n\nfunction onUnmatchedCloseParen(result) {\n  if (result.mode === PAREN_MODE) {\n    throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n  }\n  if (!result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN]) {\n    cacheErrorPos(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    var opener = peek(result.parenStack, 0);\n    if (opener) {\n      var e = cacheErrorPos(result, ERROR_UNMATCHED_OPEN_PAREN);\n      e.inputLineNo = opener.inputLineNo;\n      e.inputX = opener.inputX;\n    }\n  }\n  result.ch = \"\";\n}\n\nfunction onCloseParen(result) {\n  if (result.isInCode) {\n    if (isValidCloseParen(result.parenStack, result.ch)) {\n      onMatchedCloseParen(result);\n    }\n    else {\n      onUnmatchedCloseParen(result);\n    }\n  }\n}\n\nfunction onTab(result) {\n  if (result.isInCode) {\n    result.ch = DOUBLE_SPACE;\n  }\n}\n\nfunction onSemicolon(result) {\n  if (result.isInCode) {\n    result.isInComment = true;\n    result.commentX = result.x;\n    result.trackingArgTabStop = null;\n  }\n}\n\nfunction onNewline(result) {\n  result.isInComment = false;\n  result.ch = \"\";\n}\n\nfunction onQuote(result) {\n  if (result.isInStr) {\n    result.isInStr = false;\n  }\n  else if (result.isInComment) {\n    result.quoteDanger = !result.quoteDanger;\n    if (result.quoteDanger) {\n      cacheErrorPos(result, ERROR_QUOTE_DANGER);\n    }\n  }\n  else {\n    result.isInStr = true;\n    cacheErrorPos(result, ERROR_UNCLOSED_QUOTE);\n  }\n}\n\nfunction onBackslash(result) {\n  result.isEscaping = true;\n}\n\nfunction afterBackslash(result) {\n  result.isEscaping = false;\n  result.isEscaped = true;\n\n  if (result.ch === NEWLINE) {\n    if (result.isInCode) {\n      throw error(result, ERROR_EOL_BACKSLASH);\n    }\n    onNewline(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Character dispatch\n//------------------------------------------------------------------------------\n\nfunction onChar(result) {\n  var ch = result.ch;\n  result.isEscaped = false;\n\n  if (result.isEscaping)        { afterBackslash(result); }\n  else if (isOpenParen(ch))     { onOpenParen(result); }\n  else if (isCloseParen(ch))    { onCloseParen(result); }\n  else if (ch === DOUBLE_QUOTE) { onQuote(result); }\n  else if (ch === SEMICOLON)    { onSemicolon(result); }\n  else if (ch === BACKSLASH)    { onBackslash(result); }\n  else if (ch === TAB)          { onTab(result); }\n  else if (ch === NEWLINE)      { onNewline(result); }\n\n  ch = result.ch;\n\n  result.isInCode = !result.isInComment && !result.isInStr;\n\n  if (isClosable(result)) {\n    resetParenTrail(result, result.lineNo, result.x+ch.length);\n  }\n\n  var state = result.trackingArgTabStop;\n  if (state) {\n     trackArgTabStop(result, state);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Cursor functions\n//------------------------------------------------------------------------------\n\nfunction isCursorLeftOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX <= x // inclusive since (cursorX = x) implies (x-1 < cursor < x)\n  );\n}\n\nfunction isCursorRightOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX > x\n  );\n}\n\nfunction isCursorInComment(result, cursorX, cursorLine) {\n  return isCursorRightOf(cursorX, cursorLine, result.commentX, result.lineNo);\n}\n\nfunction handleChangeDelta(result) {\n  if (result.changes && (result.smart || result.mode === PAREN_MODE)) {\n    var line = result.changes[result.inputLineNo];\n    if (line) {\n      var change = line[result.inputX];\n      if (change) {\n        result.indentDelta += (change.newEndX - change.oldEndX);\n      }\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Paren Trail functions\n//------------------------------------------------------------------------------\n\nfunction resetParenTrail(result, lineNo, x) {\n  result.parenTrail.lineNo = lineNo;\n  result.parenTrail.startX = x;\n  result.parenTrail.endX = x;\n  result.parenTrail.openers = [];\n  result.parenTrail.clamped.startX = UINT_NULL;\n  result.parenTrail.clamped.endX = UINT_NULL;\n  result.parenTrail.clamped.openers = [];\n}\n\nfunction isCursorClampingParenTrail(result, cursorX, cursorLine) {\n  return (\n    isCursorRightOf(cursorX, cursorLine, result.parenTrail.startX, result.lineNo) &&\n    !isCursorInComment(result, cursorX, cursorLine)\n  );\n}\n\n// INDENT MODE: allow the cursor to clamp the paren trail\nfunction clampParenTrailToCursor(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  var clamping = isCursorClampingParenTrail(result, result.cursorX, result.cursorLine);\n\n  if (clamping) {\n    var newStartX = Math.max(startX, result.cursorX);\n    var newEndX = Math.max(endX, result.cursorX);\n\n    var line = result.lines[result.lineNo];\n    var removeCount = 0;\n    var i;\n    for (i = startX; i < newStartX; i++) {\n      if (isCloseParen(line[i])) {\n        removeCount++;\n      }\n    }\n\n    var openers = result.parenTrail.openers;\n\n    result.parenTrail.openers = openers.slice(removeCount);\n    result.parenTrail.startX = newStartX;\n    result.parenTrail.endX = newEndX;\n\n    result.parenTrail.clamped.openers = openers.slice(0, removeCount);\n    result.parenTrail.clamped.startX = startX;\n    result.parenTrail.clamped.endX = endX;\n  }\n}\n\n// INDENT MODE: pops the paren trail from the stack\nfunction popParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX) {\n    return;\n  }\n\n  var openers = result.parenTrail.openers;\n  while (openers.length !== 0) {\n    result.parenStack.push(openers.pop());\n  }\n}\n\nfunction getParentOpenerIndex(result, indentX) {\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    var opener = peek(result.parenStack, i);\n    var currOutside = (opener.x < indentX);\n    var prevOutside = (opener.x - opener.indentDelta < indentX);\n\n    if (prevOutside) {\n      // If an open-paren WAS outside, its `indentDelta` will be used to KEEP IT\n      // outside, by adjusting the indentation of its child lines.\n      break;\n    }\n    if (currOutside) {\n      // If an open-paren was JUST pushed outside and its parent open-paren was\n      // not pushed by same amount, new child line(s) will be adopted.\n      // Clear `indentDelta` since it is reserved for previous child lines only.\n      var nextOpener = peek(result.parenStack, i+1);\n      if (!nextOpener || nextOpener.indentDelta !== opener.indentDelta) {\n        opener.indentDelta = 0;\n        break;\n      }\n    }\n  }\n  return i;\n}\n\n// INDENT MODE: correct paren trail from indentation\nfunction correctParenTrail(result, indentX) {\n  var parens = \"\";\n\n  var index = getParentOpenerIndex(result, indentX);\n  var i;\n  for (i=0; i<index; i++) {\n    var opener = result.parenStack.pop();\n    result.parenTrail.openers.push(opener);\n    var closeCh = MATCH_PAREN[opener.ch];\n    parens += closeCh;\n\n    if (result.returnParens) {\n      setCloser(opener, result.parenTrail.lineNo, result.parenTrail.startX+i, closeCh);\n    }\n  }\n\n  if (result.parenTrail.lineNo !== UINT_NULL) {\n    replaceWithinLine(result, result.parenTrail.lineNo, result.parenTrail.startX, result.parenTrail.endX, parens);\n    result.parenTrail.endX = result.parenTrail.startX + parens.length;\n    rememberParenTrail(result);\n  }\n}\n\n// PAREN MODE: remove spaces from the paren trail\nfunction cleanParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX ||\n      result.lineNo !== result.parenTrail.lineNo) {\n    return;\n  }\n\n  var line = result.lines[result.lineNo];\n  var newTrail = \"\";\n  var spaceCount = 0;\n  var i;\n  for (i = startX; i < endX; i++) {\n    if (isCloseParen(line[i])) {\n      newTrail += line[i];\n    }\n    else {\n      spaceCount++;\n    }\n  }\n\n  if (spaceCount > 0) {\n    replaceWithinLine(result, result.lineNo, startX, endX, newTrail);\n    result.parenTrail.endX -= spaceCount;\n  }\n}\n\n// PAREN MODE: append a valid close-paren to the end of the paren trail\nfunction appendParenTrail(result) {\n  var opener = result.parenStack.pop();\n  var closeCh = MATCH_PAREN[opener.ch];\n  if (result.returnParens) {\n    setCloser(opener, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n  }\n\n  setMaxIndent(result, opener);\n  insertWithinLine(result, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n\n  result.parenTrail.endX++;\n  result.parenTrail.openers.push(opener);\n  updateRememberedParenTrail(result);\n}\n\nfunction invalidateParenTrail(result) {\n  result.parenTrail = initialParenTrail();\n}\n\nfunction checkUnmatchedOutsideParenTrail(result) {\n  var cache = result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  if (cache && cache.x < result.parenTrail.startX) {\n    throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n  }\n}\n\nfunction setMaxIndent(result, opener) {\n  if (opener) {\n    var parent = peek(result.parenStack, 0);\n    if (parent) {\n      parent.maxChildIndent = opener.x;\n    }\n    else {\n      result.maxIndent = opener.x;\n    }\n  }\n}\n\nfunction rememberParenTrail(result) {\n  var trail = result.parenTrail;\n  var openers = trail.clamped.openers.concat(trail.openers);\n  if (openers.length > 0) {\n    var isClamped = trail.clamped.startX !== UINT_NULL;\n    var allClamped = trail.openers.length === 0;\n    var shortTrail = {\n      lineNo: trail.lineNo,\n      startX: isClamped ? trail.clamped.startX : trail.startX,\n      endX: allClamped ? trail.clamped.endX : trail.endX\n    };\n    result.parenTrails.push(shortTrail);\n\n    if (result.returnParens) {\n      var i;\n      for (i=0; i<openers.length; i++) {\n        openers[i].closer.trail = shortTrail;\n      }\n    }\n  }\n}\n\nfunction updateRememberedParenTrail(result) {\n  var trail = result.parenTrails[result.parenTrails.length-1];\n  if (!trail || trail.lineNo !== result.parenTrail.lineNo) {\n    rememberParenTrail(result);\n  }\n  else {\n    trail.endX = result.parenTrail.endX;\n  }\n}\n\nfunction finishNewParenTrail(result) {\n  if (result.isInStr) {\n    invalidateParenTrail(result);\n  }\n  else if (result.mode === INDENT_MODE) {\n    clampParenTrailToCursor(result);\n    popParenTrail(result);\n  }\n  else if (result.mode === PAREN_MODE) {\n    setMaxIndent(result, peek(result.parenTrail.openers, 0));\n    if (result.lineNo !== result.cursorLine) {\n      cleanParenTrail(result);\n    }\n    rememberParenTrail(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Indentation functions\n//------------------------------------------------------------------------------\n\nfunction addIndent(result, delta) {\n  var origIndent = result.x;\n  var newIndent = origIndent + delta;\n  var indentStr = repeatString(BLANK_SPACE, newIndent);\n  replaceWithinLine(result, result.lineNo, 0, origIndent, indentStr);\n  result.x = newIndent;\n  result.indentDelta += delta;\n}\n\nfunction shouldAddOpenerIndent(result, opener) {\n  // Don't add opener.indentDelta if the user already added it.\n  // (happens when multiple lines are indented together)\n  return (opener.indentDelta !== result.indentDelta);\n}\n\nfunction correctIndent(result) {\n  var origIndent = result.x;\n  var newIndent = origIndent;\n  var minIndent = 0;\n  var maxIndent = result.maxIndent;\n\n  var opener = peek(result.parenStack, 0);\n  if (opener) {\n    minIndent = opener.x + 1;\n    maxIndent = opener.maxChildIndent;\n    if (shouldAddOpenerIndent(result, opener)) {\n      newIndent += opener.indentDelta;\n    }\n  }\n\n  newIndent = clamp(newIndent, minIndent, maxIndent);\n\n  if (newIndent !== origIndent) {\n    addIndent(result, newIndent - origIndent);\n  }\n}\n\nfunction onIndent(result) {\n  result.trackingIndent = false;\n\n  if (result.quoteDanger) {\n    throw error(result, ERROR_QUOTE_DANGER);\n  }\n\n  if (result.mode === INDENT_MODE) {\n    correctParenTrail(result, result.x);\n\n    var opener = peek(result.parenStack, 0);\n    if (opener && shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n  }\n  else if (result.mode === PAREN_MODE) {\n    correctIndent(result);\n  }\n}\n\nfunction checkLeadingCloseParen(result) {\n  if (result.errorPosCache[ERROR_LEADING_CLOSE_PAREN] &&\n      result.parenTrail.lineNo === result.lineNo) {\n    throw error(result, ERROR_LEADING_CLOSE_PAREN);\n  }\n}\n\nfunction onLeadingCloseParen(result) {\n  if (result.mode === INDENT_MODE) {\n    if (!result.forceBalance) {\n      if (result.smart) {\n        throw {leadingCloseParen: true};\n      }\n      if (!result.errorPosCache[ERROR_LEADING_CLOSE_PAREN]) {\n        cacheErrorPos(result, ERROR_LEADING_CLOSE_PAREN);\n      }\n    }\n    result.skipChar = true;\n  }\n  if (result.mode === PAREN_MODE) {\n    if (!isValidCloseParen(result.parenStack, result.ch)) {\n      throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    }\n    if (isCursorLeftOf(result.cursorX, result.cursorLine, result.x, result.lineNo)) {\n      onIndent(result);\n    }\n    else {\n      appendParenTrail(result);\n      result.skipChar = true;\n    }\n  }\n}\n\nfunction shiftCommentLine(result) {\n  var parenTrailLength = result.parenTrail.openers.length;\n\n  // restore the openers matching the previous paren trail\n  var j;\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.push(peek(result.parenTrail.openers, j));\n    }\n  }\n\n  // shift the comment line based on the parent open paren\n  var i = getParentOpenerIndex(result, result.x);\n  var opener = peek(result.parenStack, i);\n  if (opener && shouldAddOpenerIndent(result, opener)) {\n    addIndent(result, opener.indentDelta);\n  }\n\n  // repop the openers matching the previous paren trail\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.pop();\n    }\n  }\n}\n\nfunction checkIndent(result) {\n  if (isCloseParen(result.ch)) {\n    onLeadingCloseParen(result);\n  }\n  else if (result.ch === SEMICOLON) {\n    // comments don't count as indentation points\n    shiftCommentLine(result);\n    result.trackingIndent = false;\n  }\n  else if (result.ch !== NEWLINE &&\n           result.ch !== BLANK_SPACE &&\n           result.ch !== TAB) {\n    onIndent(result);\n  }\n}\n\nfunction makeTabStop(result, opener) {\n  var tabStop = {\n    ch: opener.ch,\n    x: opener.x,\n    lineNo: opener.lineNo\n  };\n  if (opener.argX != null) {\n    tabStop.argX = opener.argX;\n  }\n  return tabStop;\n}\n\nfunction getTabStopLine(result) {\n  return result.selectionStartLine !== UINT_NULL ? result.selectionStartLine : result.cursorLine;\n}\n\nfunction setTabStops(result) {\n  if (getTabStopLine(result) !== result.lineNo) {\n    return;\n  }\n\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    result.tabStops.push(makeTabStop(result, result.parenStack[i]));\n  }\n\n  if (result.mode === PAREN_MODE) {\n    for (i=result.parenTrail.openers.length-1; i>=0; i--) {\n      result.tabStops.push(makeTabStop(result, result.parenTrail.openers[i]));\n    }\n  }\n\n  // remove argX if it falls to the right of the next stop\n  for (i=1; i<result.tabStops.length; i++) {\n    var x = result.tabStops[i].x;\n    var prevArgX = result.tabStops[i-1].argX;\n    if (prevArgX != null && prevArgX >= x) {\n      delete result.tabStops[i-1].argX;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// High-level processing functions\n//------------------------------------------------------------------------------\n\nfunction processChar(result, ch) {\n  var origCh = ch;\n\n  result.ch = ch;\n  result.skipChar = false;\n\n  handleChangeDelta(result);\n\n  if (result.trackingIndent) {\n    checkIndent(result);\n  }\n\n  if (result.skipChar) {\n    result.ch = \"\";\n  }\n  else {\n    onChar(result);\n  }\n\n  commitChar(result, origCh);\n}\n\nfunction processLine(result, lineNo) {\n  initLine(result, result.inputLines[lineNo]);\n\n  setTabStops(result);\n\n  var x;\n  for (x = 0; x < result.inputLines[lineNo].length; x++) {\n    result.inputX = x;\n    processChar(result, result.inputLines[lineNo][x]);\n  }\n  processChar(result, NEWLINE);\n\n  if (!result.forceBalance) {\n    checkUnmatchedOutsideParenTrail(result);\n    checkLeadingCloseParen(result);\n  }\n\n  if (result.lineNo === result.parenTrail.lineNo) {\n    finishNewParenTrail(result);\n  }\n}\n\nfunction finalizeResult(result) {\n  if (result.quoteDanger) { throw error(result, ERROR_QUOTE_DANGER); }\n  if (result.isInStr)     { throw error(result, ERROR_UNCLOSED_QUOTE); }\n\n  if (result.parenStack.length !== 0) {\n    if (result.mode === PAREN_MODE) {\n      throw error(result, ERROR_UNCLOSED_PAREN);\n    }\n  }\n  if (result.mode === INDENT_MODE) {\n    result.x = 0;\n    onIndent(result);\n  }\n  result.success = true;\n}\n\nfunction processError(result, e) {\n  result.success = false;\n  if (e.parinferError) {\n    delete e.parinferError;\n    result.error = e;\n  }\n  else {\n    result.error.name = ERROR_UNHANDLED;\n    result.error.message = e.stack;\n    throw e;\n  }\n}\n\nfunction processText(text, options, mode, smart) {\n  var result = getInitialResult(text, options, mode, smart);\n\n  try {\n    var i;\n    for (i = 0; i < result.inputLines.length; i++) {\n      result.inputLineNo = i;\n      processLine(result, i);\n    }\n    finalizeResult(result);\n  }\n  catch (e) {\n    if (e.leadingCloseParen || e.releaseCursorHold) {\n      return processText(text, options, PAREN_MODE, smart);\n    }\n    processError(result, e);\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nfunction publicResult(result) {\n  var lineEnding = getLineEnding(result.origText);\n  var final;\n  if (result.success) {\n    final = {\n      text: result.lines.join(lineEnding),\n      cursorX: result.cursorX,\n      cursorLine: result.cursorLine,\n      success: true,\n      tabStops: result.tabStops,\n      parenTrails: result.parenTrails\n    };\n    if (result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  else {\n    final = {\n      text: result.partialResult ? result.lines.join(lineEnding) : result.origText,\n      cursorX: result.partialResult ? result.cursorX : result.origCursorX,\n      cursorLine: result.partialResult ? result.cursorLine : result.origCursorLine,\n      parenTrails: result.partialResult ? result.parenTrails : null,\n      success: false,\n      error: result.error\n    };\n    if (result.partialResult && result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  if (final.cursorX === UINT_NULL) { delete final.cursorX; }\n  if (final.cursorLine === UINT_NULL) { delete final.cursorLine; }\n  if (final.tabStops && final.tabStops.length === 0) { delete final.tabStops; }\n  return final;\n}\n\nfunction indentMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, INDENT_MODE));\n}\n\nfunction parenMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, PAREN_MODE));\n}\n\nfunction smartMode(text, options) {\n  options = parseOptions(options);\n  var smart = options.selectionStartLine == null;\n  return publicResult(processText(text, options, INDENT_MODE, smart));\n}\n\nvar API = {\n  version: \"3.10.0\",\n  indentMode: indentMode,\n  parenMode: parenMode,\n  smartMode: smartMode\n};\n\nreturn API;\n\n})); // end module anonymous scope\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","root","factory","define","amd","parinfer","isInteger","x","isFinite","Math","floor","parseOptions","options","cursorX","cursorLine","prevCursorX","prevCursorLine","selectionStartLine","changes","partialResult","forceBalance","returnParens","initialParenTrail","lineNo","UINT_NULL","startX","endX","openers","clamped","cacheErrorPos","result","errorName","e","inputLineNo","inputX","errorPosCache","error","name","cache","keyLineNo","keyX","parinferError","message","errorMessages","opener","peek","parenStack","ERROR_UNMATCHED_CLOSE_PAREN","ERROR_UNMATCHED_OPEN_PAREN","extra","ERROR_UNCLOSED_PAREN","replaceWithinLine","start","end","replace","line","lines","orig","substring","newLine","dx","length","arr","idxFromBack","maxIdx","isCloseParen","ch","isValidCloseParen","MATCH_PAREN","isWhitespace","isEscaped","BLANK_SPACE","DOUBLE_SPACE","isCursorRightOf","resetParenTrail","parenTrail","getParentOpenerIndex","indentX","i","indentDelta","nextOpener","setMaxIndent","parent","maxChildIndent","maxIndent","rememberParenTrail","trail","concat","shortTrail","parenTrails","push","closer","addIndent","delta","origIndent","newIndent","onIndent","trackingIndent","quoteDanger","ERROR_QUOTE_DANGER","INDENT_MODE","mode","parens","index","pop","closeCh","PAREN_MODE","minIndent","val","max","min","makeTabStop","tabStop","argX","processChar","skipChar","smart","change","newEndX","oldEndX","leadingCloseParen","ERROR_LEADING_CLOSE_PAREN","idx","SEMICOLON","parenTrailLength","j","NEWLINE","TAB","isEscaping","isInCode","ERROR_EOL_BACKSLASH","isInComment","children","trackingArgTabStop","holdMinX","holdMaxX","holding","releaseCursorHold","origStartX","origEndX","origOpeners","DOUBLE_QUOTE","isInStr","ERROR_UNCLOSED_QUOTE","commentX","BACKSLASH","state","processText","text","origText","origCursorX","origCursorLine","inputLines","split","LINE_ENDING_REGEX","tabStops","success","Array","isArray","newLines","newText","oldLines","oldText","newEndLineNo","lookupLineNo","lookupX","prevArgX","newStartX","removeCount","slice","newTrail","spaceCount","ERROR_UNHANDLED","stack","publicResult","search","final","join","lineEnding","API","version","indentMode","parenMode","smartMode"]
}
