{"version":3,"file":"fulcro.client.impl.data_targeting.js","sources":["fulcro/client/impl/data_targeting.cljc"],"mappings":"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","names":["var_args","args__4502__auto__","len__4499__auto__","i__4500__auto__","argseq__4503__auto__","cljs.core/IndexedSeq","fulcro.client.impl.data-targeting/multiple-targets","seq36741","self__4487__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","fulcro.client.impl.data-targeting/prepend-to","target","fulcro.client.impl.data-targeting/append-to","fulcro.client.impl.data-targeting/replace-at","fulcro.client.impl.data-targeting/replacement-target?","t","cljs.core/meta","cljs.core/boolean","fulcro.client.impl.data-targeting/prepend-target?","fulcro.client.impl.data-targeting/append-target?","fulcro.client.impl.data-targeting/multiple-targets?","fulcro.client.impl.data-targeting/special-target?","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","fulcro.client.impl.data-targeting/integrate-ident","js/Error","seq36760","G__36761","cljs.core/first","cljs.core/next","G__36762","self__4486__auto__","state","ident","named-parameters","cljs.core/map?","actions","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__36763","vec__36764","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","command","data-path","already-has-ident-at-path?","p1__36757#","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","G__36770","cljs.core/Keyword","cljs.core/vector?","p1__36758#","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","cljs.core/contains?","cljs.core/assoc-in","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","G__36794","fulcro.client.impl.data-targeting/process-target","source-path","fulcro.client.impl.data_targeting.process_target.cljs$core$IFn$_invoke$arity$4","remove-ok?","item-to-place","fulcro.util/ident?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","many-idents?","cljs.core/every?","cljs.core/not","G__36796","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__36798","s","and__3911__auto__","target-has-many?","v","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","G__36804","fulcro.client.impl.data_targeting.integrate_ident.cljs$core$IFn$_invoke$arity$variadic"],"sourcesContent":["(ns fulcro.client.impl.data-targeting\n  (:require [clojure.set :as set]\n            [fulcro.util :as util]))\n\n(defn multiple-targets [& targets]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(defn prepend-to [target]\n  (with-meta target {::prepend-target true}))\n\n(defn append-to [target]\n  (with-meta target {::append-target true}))\n\n(defn replace-at [target]\n  (with-meta target {::replace-target true}))\n\n(defn replacement-target? [t] (-> t meta ::replace-target boolean))\n(defn prepend-target? [t] (-> t meta ::prepend-target boolean))\n(defn append-target? [t] (-> t meta ::append-target boolean))\n(defn multiple-targets? [t] (-> t meta ::multiple-targets boolean))\n\n(defn special-target? [target]\n  (boolean (seq (set/intersection (-> target meta keys) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(defn integrate-ident\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not append\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\"\n  [state ident & named-parameters]\n  {:pre [(map? state)]}\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (do\n                               (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for prepend must target an app-state vector.\"))\n                               (update-in state data-path #(into [ident] %))))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (do\n                              (assert (vector? (get-in state data-path)) (str \"Path \" data-path \" for append must target an app-state vector.\"))\n                              (update-in state data-path conj ident)))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (assert (vector? data-path) (str \"Replacement path must be a vector. You passed: \" data-path))\n                             (when to-many?\n                               (do\n                                 (assert (vector? vector) \"Path for replacement must be a vector\")\n                                 (assert (number? index) \"Path for replacement must end in a vector index\")\n                                 (assert (contains? vector index) (str \"Target vector for replacement does not have an item at index \" index))))\n                             (assoc-in state data-path ident))\n                  (throw (ex-info \"Unknown post-op to merge-state!: \" {:command command :arg data-path})))))\n            state actions)))\n\n(defn process-target\n  ([state source-path target] (process-target state source-path target true))\n  ([state source-path target remove-ok?]\n   {:pre [(vector? target)]}\n   (let [item-to-place (cond (util/ident? source-path) source-path\n                             (keyword? source-path) (get state source-path)\n                             :else (get-in state source-path))\n         many-idents?  (and (vector? item-to-place)\n                            (every? util/ident? item-to-place))]\n     (cond\n       (and (util/ident? source-path)\n            (not (special-target? target))) (-> state\n                                                (assoc-in target item-to-place))\n       (not (special-target? target)) (cond->\n                                        (assoc-in state target item-to-place)\n                                        remove-ok? (dissoc source-path))\n       (multiple-targets? target) (cond-> (reduce (fn [s t] (process-target s source-path t false)) state target)\n                                    (and (not (util/ident? source-path)) remove-ok?) (dissoc source-path))\n       (and many-idents? (special-target? target)) (let [state            (if remove-ok?\n                                                                            (dissoc state source-path)\n                                                                            state)\n                                                         target-has-many? (vector? (get-in state target))]\n                                                     (if target-has-many?\n                                                       (cond\n                                                         (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                                                         (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                                                         :else state)\n                                                       (assoc-in state target item-to-place)))\n       (special-target? target) (cond-> state\n                                  remove-ok? (dissoc source-path)\n                                  (prepend-target? target) (integrate-ident item-to-place :prepend target)\n                                  (append-target? target) (integrate-ident item-to-place :append target)\n                                  (replacement-target? target) (integrate-ident item-to-place :replace target))\n       :else state))))\n"]}