{
"version":3,
"file":"module$node_modules$codemirror$mode$clojure$clojure.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/codemirror/mode/clojure/clojure.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$clojure$clojure\"] = function(global,process,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Hans Engel\n * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"variable\";\n    var INDENT_WORD_SKIP = options.indentUnit || 2;\n    var NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var atoms = makeKeywords(\"true false nil\");\n\n    var keywords = makeKeywords(\n      \"defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest \" +\n      \"slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn \" +\n      \"do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync \" +\n      \"doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars \" +\n      \"binding gen-class gen-and-load-class gen-and-save-class handler-case handle\");\n\n    var builtins = makeKeywords(\n        \"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* \" +\n        \"*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* \" +\n        \"*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* \" +\n        \"*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> \" +\n        \"->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor \" +\n        \"aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! \" +\n        \"alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double \" +\n        \"aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 \" +\n        \"bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set \" +\n        \"bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast \" +\n        \"byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append \" +\n        \"chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors \" +\n        \"clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond condp \" +\n        \"conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? \" +\n        \"declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol \" +\n        \"defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc \" +\n        \"dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last \" +\n        \"drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info \" +\n        \"extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword \" +\n        \"find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? \" +\n        \"fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? \" +\n        \"gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash \" +\n        \"hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? \" +\n        \"int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep \" +\n        \"keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file \" +\n        \"load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array \" +\n        \"make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods \" +\n        \"min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty \" +\n        \"not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias \" +\n        \"ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all \" +\n        \"partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers \" +\n        \"primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str \" +\n        \"prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues \" +\n        \"quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern \" +\n        \"re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history \" +\n        \"ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods \" +\n        \"remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest \" +\n        \"restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? \" +\n        \"seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts \" +\n        \"shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? \" +\n        \"special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol \" +\n        \"symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce \" +\n        \"transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec \" +\n        \"unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int \" +\n        \"unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int \"+\n        \"unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote \" +\n        \"unquote-splicing update update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of \" +\n        \"vector? volatile! volatile? vreset! vswap! when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context \" +\n        \"with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap \" +\n        \"*default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! \" +\n        \"set-agent-send-off-executor! some-> some->>\");\n\n    var indentKeys = makeKeywords(\n        // Built-ins\n        \"ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto \" +\n        \"locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type \" +\n        \"try catch \" +\n\n        // Binding forms\n        \"let letfn binding loop for doseq dotimes when-let if-let \" +\n\n        // Data structures\n        \"defstruct struct-map assoc \" +\n\n        // clojure.test\n        \"testing deftest \" +\n\n        // contrib\n        \"handler-case handle dotrace deftrace\");\n\n    var tests = {\n        digit: /\\d/,\n        digit_or_colon: /[\\d:]/,\n        hex: /[0-9a-f]/i,\n        sign: /[+-]/,\n        exponent: /e/i,\n        keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n        symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/,\n        block_indent: /^(?:def|with)[^\\/]+$|\\/(?:def|with)/\n    };\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    function isNumber(ch, stream){\n        // hex\n        if ( ch === '0' && stream.eat(/x/i) ) {\n            stream.eatWhile(tests.hex);\n            return true;\n        }\n\n        // leading sign\n        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n          stream.eat(tests.sign);\n          ch = stream.next();\n        }\n\n        if ( tests.digit.test(ch) ) {\n            stream.eat(ch);\n            stream.eatWhile(tests.digit);\n\n            if ( '.' == stream.peek() ) {\n                stream.eat('.');\n                stream.eatWhile(tests.digit);\n            } else if ('/' == stream.peek() ) {\n                stream.eat('/');\n                stream.eatWhile(tests.digit);\n            }\n\n            if ( stream.eat(tests.exponent) ) {\n                stream.eat(tests.sign);\n                stream.eatWhile(tests.digit);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n        var first = stream.next();\n        // Read special literals: backspace, newline, space, return.\n        // Just read all lowercase letters.\n        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n            return;\n        }\n        // Read unicode character: \\u1000 \\uA0a1\n        if (first === \"u\") {\n            stream.match(/[0-9a-z]{4}/i, true);\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (state.mode != \"string\" && stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in string mode\n                    break;\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n                    } else if (ch == \"\\\\\") {\n                        eatCharacter(stream);\n                        returnType = CHARACTER;\n                    } else if (ch == \"'\" && !( tests.digit_or_colon.test(stream.peek()) )) {\n                        returnType = ATOM;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (isNumber(ch,stream)){\n                        returnType = NUMBER;\n                    } else if (ch == \"(\" || ch == \"[\" || ch == \"{\" ) {\n                        var keyWord = '', indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        if (ch == \"(\") while ((letter = stream.eat(tests.keyword_char)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||\n                                                   tests.block_indent.test(keyWord))) { // indent-word\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation the user defined spaces after\n                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\" || ch == \"}\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : (ch == \"]\" ? \"[\" :\"{\"))) {\n                            popStack(state);\n                        }\n                    } else if ( ch == \":\" ) {\n                        stream.eatWhile(tests.symbol);\n                        return ATOM;\n                    } else {\n                        stream.eatWhile(tests.symbol);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = KEYWORD;\n                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {\n                            returnType = ATOM;\n                        } else {\n                          returnType = VAR;\n                        }\n                    }\n            }\n\n            return returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\nCodeMirror.defineMIME(\"text/x-clojurescript\", \"clojure\");\nCodeMirror.defineMIME(\"application/edn\", \"clojure\");\n\n});\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","mod","define","amd","CodeMirror","defineMode","options","makeKeywords","str","obj","words","split","i","length","stateStack","indent","type","prev","INDENT_WORD_SKIP","indentUnit","NORMAL_INDENT_UNIT","atoms","keywords","builtins","indentKeys","startState","indentStack","indentation","mode","token","stream","state","sol","eatSpace","next","escaped","returnType","STRING","ch","first","match","CHARACTER","digit_or_colon","test","peek","skipToEnd","COMMENT","eat","eatWhile","hex","digit","sign","exponent","NUMBER","keyWord","indentTemp","column","letter","keyword_char","propertyIsEnumerable","block_indent","eol","current","backUp","BRACKET","symbol","ATOM","KEYWORD","BUILTIN","VAR","closeBrackets","pairs","lineComment","defineMIME"]
}
